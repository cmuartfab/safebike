   1               		.file	"main.c"
   2               	__SP_H__ = 0x3e
   3               	__SP_L__ = 0x3d
   4               	__SREG__ = 0x3f
   5               	__RAMPZ__ = 0x3b
   6               	__tmp_reg__ = 0
   7               	__zero_reg__ = 1
  10               		.text
  11               	.Ltext0:
 337               	.global	task_imu
 339               	task_imu:
 340               		.stabd	46,0,0
   1:main.c        **** /******************************************************************************
   2:main.c        **** *  Nano-RK, a real-time operating system for sensor networks.
   3:main.c        **** *  Copyright (C) 2007, Real-Time and Multimedia Lab, Carnegie Mellon University
   4:main.c        **** *  All rights reserved.
   5:main.c        **** *
   6:main.c        **** *  This is the Open Source Version of Nano-RK included as part of a Dual
   7:main.c        **** *  Licensing Model. If you are unsure which license to use please refer to:
   8:main.c        **** *  http://www.nanork.org/nano-RK/wiki/Licensing
   9:main.c        **** *
  10:main.c        **** *  This program is free software: you can redistribute it and/or modify
  11:main.c        **** *  it under the terms of the GNU General Public License as published by
  12:main.c        **** *  the Free Software Foundation, version 2.0 of the License.
  13:main.c        **** *
  14:main.c        **** *  This program is distributed in the hope that it will be useful,
  15:main.c        **** *  but WITHOUT ANY WARRANTY; without even the implied warranty of
  16:main.c        **** *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  17:main.c        **** *  GNU General Public License for more details.
  18:main.c        **** *
  19:main.c        **** *  You should have received a copy of the GNU General Public License
  20:main.c        **** *  along with this program.  If not, see <http://www.gnu.org/licenses/>.
  21:main.c        **** *
  22:main.c        **** *******************************************************************************/
  23:main.c        **** 
  24:main.c        **** #include <nrk.h>
  25:main.c        **** #include <include.h>
  26:main.c        **** #include <ulib.h>
  27:main.c        **** #include <stdio.h>
  28:main.c        **** #include <hal.h>
  29:main.c        **** #include <nrk_error.h>
  30:main.c        **** #include <nrk_timer.h>
  31:main.c        **** #include <nrk_stack_check.h>
  32:main.c        **** #include <nrk_stats.h>
  33:main.c        **** #include <pcf_tdma.h>
  34:main.c        **** #include <TWI_Master.h>
  35:main.c        **** #include <tdma_cons.h>
  36:main.c        **** 
  37:main.c        **** // Constants for the accelrometer
  38:main.c        **** //There are 6 data registers, they are sequential starting 
  39:main.c        **** //with the LSB of X.  We'll read all 6 in a burst and won't
  40:main.c        **** //address them individually
  41:main.c        **** #define ADXL345_REGISTER_XLSB 0x32
  42:main.c        **** #define ADXL_REGISTER_DTFMT 0x31
  43:main.c        **** //Need to set power control bit to wake up the adxl345
  44:main.c        **** #define ADXL_REGISTER_PWRCTL 0x2D
  45:main.c        **** #define ADXL_REGISTER_FIFOCTL 0x38
  46:main.c        **** #define ADXL_FIFOCTL_STREAM 1<<7
  47:main.c        **** #define ADXL_PWRCTL_MEASURE 1 << 3
  48:main.c        **** #define ADXL_16G_DTFMT 0x0F
  49:main.c        **** #define ADXL_PWRCTL_STBY 0
  50:main.c        **** #define ADXL345_ADDRESS 0xA6
  51:main.c        **** #define ADXL_SIZE 6
  52:main.c        **** 
  53:main.c        **** 
  54:main.c        **** //Constants for the gyroscope
  55:main.c        **** #define ITG3200_ADDRESS 0xD0
  56:main.c        **** //request burst of 6 bytes from this address
  57:main.c        **** #define ITG3200_REGISTER_XMSB 0x1D
  58:main.c        **** #define ITG3200_REGISTER_DLPF 0x16
  59:main.c        **** #define ITG3200_FULLSCALE 0x03 << 3
  60:main.c        **** #define ITG3200_42HZ 0x03
  61:main.c        **** #define ITG3200_SIZE 6
  62:main.c        **** 
  63:main.c        **** 
  64:main.c        **** #define HMC5843_ADDRESS 0x3C
  65:main.c        **** //First data address of 6 is XMSB.  Also need to set a configuration register for
  66:main.c        **** //continuous measurement
  67:main.c        **** #define HMC5843_REGISTER_XMSB 0x03
  68:main.c        **** #define HMC5843_REGISTER_MEASMODE 0x02
  69:main.c        **** #define HMC5843_MEASMODE_CONT 0x00
  70:main.c        **** #define HMC5843_SIZE 6
  71:main.c        **** 
  72:main.c        **** 
  73:main.c        **** tdma_info tx_tdma_fd;
  74:main.c        **** tdma_info rx_tdma_fd;
  75:main.c        **** 
  76:main.c        **** uint8_t i2c_buf[16];
  77:main.c        **** uint8_t tx_buf[TDMA_MAX_PKT_SIZE];
  78:main.c        **** uint8_t pkt[TDMA_MAX_PKT_SIZE];
  79:main.c        **** uint8_t tx_len;
  80:main.c        **** unsigned int sequenceNo; 
  81:main.c        **** bool packetReady;
  82:main.c        **** uint16_t mac_address;
  83:main.c        **** 
  84:main.c        **** uint8_t aes_key[] = {0x00,0x11,0x22,0x33,0x44,0x55,0x66,0x77,0x88,0x99,0xaa,0xbb,0xcc,0xdd,0xee, 0x
  85:main.c        **** 
  86:main.c        **** NRK_STK Stack1[NRK_APP_STACKSIZE];
  87:main.c        **** nrk_task_type TaskOne;
  88:main.c        **** void task_imu(void);
  89:main.c        **** 
  90:main.c        **** NRK_STK rx_task_stack[NRK_APP_STACKSIZE];
  91:main.c        **** nrk_task_type rx_task_info;
  92:main.c        **** void rx_task (void);
  93:main.c        **** 
  94:main.c        **** NRK_STK tx_task_stack[NRK_APP_STACKSIZE];
  95:main.c        **** nrk_task_type tx_task_info;
  96:main.c        **** void tx_task (void);
  97:main.c        **** 
  98:main.c        **** 
  99:main.c        **** void init_adxl345(void);
 100:main.c        **** void init_itg3200(void);
 101:main.c        **** void init_hmc5843(void);
 102:main.c        **** 
 103:main.c        **** void nrk_create_taskset();
 104:main.c        **** 
 105:main.c        **** int main ()
 106:main.c        **** { 
 107:main.c        **** 
 108:main.c        ****   nrk_setup_ports();
 109:main.c        ****   nrk_setup_uart(UART_BAUDRATE_115K2);
 110:main.c        ****   nrk_init();
 111:main.c        **** 
 112:main.c        ****   TWI_Master_Initialise();
 113:main.c        ****   sei();
 114:main.c        ****   init_adxl345();
 115:main.c        ****   init_itg3200();
 116:main.c        ****   init_hmc5843();
 117:main.c        ****   /* initialize sequence number, used to sync with master */
 118:main.c        ****   sequenceNo = 0; 
 119:main.c        **** 
 120:main.c        ****   /* initialize tx_buf ready flag */
 121:main.c        ****   packetReady = false;
 122:main.c        ****   
 123:main.c        **** 
 124:main.c        ****   mac_address = CLIENT_MAC;
 125:main.c        ****   printf("mac = %d\r\n",mac_address);
 126:main.c        ****   tdma_init (TDMA_CLIENT, DEFAULT_CHANNEL, CLIENT_MAC);
 127:main.c        **** 
 128:main.c        ****   //tdma_aes_setkey(aes_key);
 129:main.c        ****   //tdma_aes_enable();
 130:main.c        **** 
 131:main.c        ****   tdma_tx_slot_add (mac_address&0xFFFF);
 132:main.c        **** 
 133:main.c        ****   nrk_led_clr(ORANGE_LED);
 134:main.c        ****   nrk_led_clr(BLUE_LED);
 135:main.c        ****   nrk_led_clr(GREEN_LED);
 136:main.c        ****   nrk_led_clr(RED_LED);
 137:main.c        ****  
 138:main.c        ****   nrk_time_set(0,0);
 139:main.c        ****   nrk_create_taskset();
 140:main.c        ****   nrk_start();
 141:main.c        ****   
 142:main.c        ****   return 0;
 143:main.c        **** }
 144:main.c        **** 
 145:main.c        **** void init_itg3200() {
 146:main.c        ****     /* put in standby mode while we change fifo control bits */
 147:main.c        ****   i2c_buf[0] = ITG3200_ADDRESS | FALSE<<TWI_READ_BIT;
 148:main.c        ****   i2c_buf[1] = ITG3200_REGISTER_DLPF;
 149:main.c        ****   i2c_buf[2] = ITG3200_FULLSCALE | ITG3200_42HZ;
 150:main.c        ****   TWI_Start_Transceiver_With_Data(i2c_buf, 3);
 151:main.c        **** }
 152:main.c        **** 
 153:main.c        **** void init_hmc5843() {
 154:main.c        ****     /* put in standby mode while we change fifo control bits */
 155:main.c        ****   i2c_buf[0] = HMC5843_ADDRESS | FALSE<<TWI_READ_BIT;
 156:main.c        ****   i2c_buf[1] = HMC5843_REGISTER_MEASMODE;
 157:main.c        ****   i2c_buf[2] = HMC5843_MEASMODE_CONT;
 158:main.c        ****   TWI_Start_Transceiver_With_Data(i2c_buf, 3);
 159:main.c        **** }
 160:main.c        **** 
 161:main.c        **** 
 162:main.c        **** void init_adxl345() {
 163:main.c        ****   unsigned int read = 0;
 164:main.c        **** 
 165:main.c        ****   /* put in standby mode while we change fifo control bits */
 166:main.c        ****   i2c_buf[0] = ADXL345_ADDRESS | FALSE<<TWI_READ_BIT;
 167:main.c        ****   i2c_buf[1] = ADXL_REGISTER_PWRCTL;
 168:main.c        ****   i2c_buf[2] = ADXL_PWRCTL_STBY;
 169:main.c        ****   TWI_Start_Transceiver_With_Data(i2c_buf, 3);
 170:main.c        **** 
 171:main.c        ****   /* set the fifo mode to stream */
 172:main.c        ****   i2c_buf[0] = ADXL345_ADDRESS | FALSE<<TWI_READ_BIT;
 173:main.c        ****   i2c_buf[1] = ADXL_REGISTER_FIFOCTL;
 174:main.c        ****   i2c_buf[2] = ADXL_FIFOCTL_STREAM;
 175:main.c        ****   TWI_Start_Transceiver_With_Data(i2c_buf,3);
 176:main.c        **** 
 177:main.c        ****   /* set data format to full resolution +-16g */
 178:main.c        ****   i2c_buf[0] = ADXL345_ADDRESS | FALSE<<TWI_READ_BIT;
 179:main.c        ****   i2c_buf[1] = ADXL_REGISTER_DTFMT;
 180:main.c        ****   i2c_buf[2] = ADXL_16G_DTFMT;
 181:main.c        ****   TWI_Start_Transceiver_With_Data(i2c_buf,3);
 182:main.c        **** 
 183:main.c        ****   /* set to measure mode */
 184:main.c        ****   i2c_buf[0] = ADXL345_ADDRESS | FALSE<<TWI_READ_BIT;
 185:main.c        ****   i2c_buf[1] = ADXL_REGISTER_PWRCTL;
 186:main.c        ****   i2c_buf[2] = ADXL_PWRCTL_MEASURE;
 187:main.c        ****   TWI_Start_Transceiver_With_Data(i2c_buf, 3);
 188:main.c        **** }
 189:main.c        **** 
 190:main.c        **** void task_imu(){
 342               	.LM0:
 343               	.LFBB1:
 344               	/* prologue: function */
 345               	/* frame size = 0 */
 346               	/* stack size = 0 */
 347               	.L__stack_usage = 0
 191:main.c        ****   unsigned int i;
 192:main.c        ****   unsigned int count;
 193:main.c        ****   int v;
 194:main.c        ****   
 195:main.c        ****   while(1){
 196:main.c        ****     i = 0;
 197:main.c        ****     tx_buf[i++] = NODE_ADDR;
 349               	.LM1:
 350 0000 82E0      		ldi r24,lo8(2)
 351 0002 F82E      		mov r15,r24
 198:main.c        ****     tx_buf[i++] = sequenceNo++;
 199:main.c        ****     
 200:main.c        ****     i2c_buf[0] = (ADXL345_ADDRESS) | (FALSE<<TWI_READ_BIT);
 353               	.LM2:
 354 0004 96EA      		ldi r25,lo8(-90)
 355 0006 E92E      		mov r14,r25
 201:main.c        ****     i2c_buf[1] = ADXL345_REGISTER_XLSB;
 357               	.LM3:
 358 0008 22E3      		ldi r18,lo8(50)
 359 000a D22E      		mov r13,r18
 202:main.c        ****     TWI_Start_Transceiver_With_Data(i2c_buf, 2);
 203:main.c        **** 
 204:main.c        **** 
 205:main.c        ****     /* Read first byte */
 206:main.c        ****     i2c_buf[0] = (ADXL345_ADDRESS) | (TRUE<<TWI_READ_BIT);
 361               	.LM4:
 362 000c 37EA      		ldi r19,lo8(-89)
 363 000e C32E      		mov r12,r19
 207:main.c        **** 
 208:main.c        ****     TWI_Start_Transceiver_With_Data(i2c_buf, 7);
 209:main.c        ****     TWI_Get_Data_From_Transceiver(i2c_buf,7);
 210:main.c        ****     for (count = 0; count < ADXL_SIZE; count++){
 211:main.c        ****       tx_buf[i++] = i2c_buf[count+1];
 212:main.c        ****     }
 213:main.c        **** 
 214:main.c        ****     i2c_buf[0] = (ITG3200_ADDRESS) | (FALSE<<TWI_READ_BIT);
 365               	.LM5:
 366 0010 40ED      		ldi r20,lo8(-48)
 367 0012 B42E      		mov r11,r20
 215:main.c        ****     i2c_buf[1] = ITG3200_REGISTER_XMSB;
 369               	.LM6:
 370 0014 5DE1      		ldi r21,lo8(29)
 371 0016 A52E      		mov r10,r21
 216:main.c        ****     TWI_Start_Transceiver_With_Data(i2c_buf, 2);
 217:main.c        **** 
 218:main.c        ****     /* Read first byte */
 219:main.c        ****     i2c_buf[0] = (ITG3200_ADDRESS) | (TRUE<<TWI_READ_BIT);
 373               	.LM7:
 374 0018 61ED      		ldi r22,lo8(-47)
 375 001a 962E      		mov r9,r22
 220:main.c        ****     TWI_Start_Transceiver_With_Data(i2c_buf, 7);
 221:main.c        ****     TWI_Get_Data_From_Transceiver(i2c_buf,7);
 222:main.c        ****     for (count = 0; count < ITG3200_SIZE; count++){
 223:main.c        ****       tx_buf[i++] = i2c_buf[count+1];
 224:main.c        ****     }
 225:main.c        **** 
 226:main.c        ****     i2c_buf[0] = (HMC5843_ADDRESS) | (FALSE<<TWI_READ_BIT);
 377               	.LM8:
 378 001c 7CE3      		ldi r23,lo8(60)
 379 001e 872E      		mov r8,r23
 227:main.c        ****     i2c_buf[1] = HMC5843_REGISTER_XMSB;
 381               	.LM9:
 382 0020 E3E0      		ldi r30,lo8(3)
 383 0022 7E2E      		mov r7,r30
 228:main.c        ****     TWI_Start_Transceiver_With_Data(i2c_buf, 2);
 229:main.c        **** 
 230:main.c        ****     /* Read first byte */
 231:main.c        ****     i2c_buf[0] = (HMC5843_ADDRESS) | (TRUE<<TWI_READ_BIT);
 385               	.LM10:
 386 0024 FDE3      		ldi r31,lo8(61)
 387 0026 6F2E      		mov r6,r31
 388               	.L7:
 197:main.c        ****     tx_buf[i++] = sequenceNo++;
 390               	.LM11:
 391 0028 F092 0000 		sts tx_buf,r15
 198:main.c        ****     
 393               	.LM12:
 394 002c 8091 0000 		lds r24,sequenceNo
 395 0030 9091 0000 		lds r25,sequenceNo+1
 396 0034 9C01      		movw r18,r24
 397 0036 2F5F      		subi r18,-1
 398 0038 3F4F      		sbci r19,-1
 399 003a 3093 0000 		sts sequenceNo+1,r19
 400 003e 2093 0000 		sts sequenceNo,r18
 401 0042 8093 0000 		sts tx_buf+1,r24
 200:main.c        ****     i2c_buf[1] = ADXL345_REGISTER_XLSB;
 403               	.LM13:
 404 0046 E092 0000 		sts i2c_buf,r14
 201:main.c        ****     TWI_Start_Transceiver_With_Data(i2c_buf, 2);
 406               	.LM14:
 407 004a D092 0000 		sts i2c_buf+1,r13
 202:main.c        **** 
 409               	.LM15:
 410 004e 62E0      		ldi r22,lo8(2)
 411 0050 80E0      		ldi r24,lo8(i2c_buf)
 412 0052 90E0      		ldi r25,hi8(i2c_buf)
 413 0054 0E94 0000 		call TWI_Start_Transceiver_With_Data
 206:main.c        **** 
 415               	.LM16:
 416 0058 C092 0000 		sts i2c_buf,r12
 208:main.c        ****     TWI_Get_Data_From_Transceiver(i2c_buf,7);
 418               	.LM17:
 419 005c 67E0      		ldi r22,lo8(7)
 420 005e 80E0      		ldi r24,lo8(i2c_buf)
 421 0060 90E0      		ldi r25,hi8(i2c_buf)
 422 0062 0E94 0000 		call TWI_Start_Transceiver_With_Data
 209:main.c        ****     for (count = 0; count < ADXL_SIZE; count++){
 424               	.LM18:
 425 0066 67E0      		ldi r22,lo8(7)
 426 0068 80E0      		ldi r24,lo8(i2c_buf)
 427 006a 90E0      		ldi r25,hi8(i2c_buf)
 428 006c 0E94 0000 		call TWI_Get_Data_From_Transceiver
 198:main.c        ****     
 430               	.LM19:
 431 0070 82E0      		ldi r24,lo8(2)
 432 0072 90E0      		ldi r25,0
 433               	.L2:
 211:main.c        ****     }
 435               	.LM20:
 436 0074 EC01      		movw r28,r24
 437 0076 2196      		adiw r28,1
 438 0078 FC01      		movw r30,r24
 439 007a E050      		subi r30,lo8(-(i2c_buf-1))
 440 007c F040      		sbci r31,hi8(-(i2c_buf-1))
 441 007e 2081      		ld r18,Z
 442 0080 FC01      		movw r30,r24
 443 0082 E050      		subi r30,lo8(-(tx_buf))
 444 0084 F040      		sbci r31,hi8(-(tx_buf))
 445 0086 2083      		st Z,r18
 446 0088 CE01      		movw r24,r28
 210:main.c        ****       tx_buf[i++] = i2c_buf[count+1];
 448               	.LM21:
 449 008a C830      		cpi r28,8
 450 008c D105      		cpc r29,__zero_reg__
 451 008e 01F4      		brne .L2
 214:main.c        ****     i2c_buf[1] = ITG3200_REGISTER_XMSB;
 453               	.LM22:
 454 0090 B092 0000 		sts i2c_buf,r11
 215:main.c        ****     TWI_Start_Transceiver_With_Data(i2c_buf, 2);
 456               	.LM23:
 457 0094 A092 0000 		sts i2c_buf+1,r10
 216:main.c        **** 
 459               	.LM24:
 460 0098 62E0      		ldi r22,lo8(2)
 461 009a 80E0      		ldi r24,lo8(i2c_buf)
 462 009c 90E0      		ldi r25,hi8(i2c_buf)
 463 009e 0E94 0000 		call TWI_Start_Transceiver_With_Data
 219:main.c        ****     TWI_Start_Transceiver_With_Data(i2c_buf, 7);
 465               	.LM25:
 466 00a2 9092 0000 		sts i2c_buf,r9
 220:main.c        ****     TWI_Get_Data_From_Transceiver(i2c_buf,7);
 468               	.LM26:
 469 00a6 67E0      		ldi r22,lo8(7)
 470 00a8 80E0      		ldi r24,lo8(i2c_buf)
 471 00aa 90E0      		ldi r25,hi8(i2c_buf)
 472 00ac 0E94 0000 		call TWI_Start_Transceiver_With_Data
 221:main.c        ****     for (count = 0; count < ITG3200_SIZE; count++){
 474               	.LM27:
 475 00b0 67E0      		ldi r22,lo8(7)
 476 00b2 80E0      		ldi r24,lo8(i2c_buf)
 477 00b4 90E0      		ldi r25,hi8(i2c_buf)
 478 00b6 0E94 0000 		call TWI_Get_Data_From_Transceiver
 479               	.L3:
 223:main.c        ****     }
 481               	.LM28:
 482 00ba 8E01      		movw r16,r28
 483 00bc 0F5F      		subi r16,-1
 484 00be 1F4F      		sbci r17,-1
 485 00c0 FE01      		movw r30,r28
 486 00c2 E050      		subi r30,lo8(-(i2c_buf-7))
 487 00c4 F040      		sbci r31,hi8(-(i2c_buf-7))
 488 00c6 8081      		ld r24,Z
 489 00c8 C050      		subi r28,lo8(-(tx_buf))
 490 00ca D040      		sbci r29,hi8(-(tx_buf))
 491 00cc 8883      		st Y,r24
 492 00ce E801      		movw r28,r16
 222:main.c        ****       tx_buf[i++] = i2c_buf[count+1];
 494               	.LM29:
 495 00d0 0E30      		cpi r16,14
 496 00d2 1105      		cpc r17,__zero_reg__
 497 00d4 01F4      		brne .L3
 226:main.c        ****     i2c_buf[1] = HMC5843_REGISTER_XMSB;
 499               	.LM30:
 500 00d6 8092 0000 		sts i2c_buf,r8
 227:main.c        ****     TWI_Start_Transceiver_With_Data(i2c_buf, 2);
 502               	.LM31:
 503 00da 7092 0000 		sts i2c_buf+1,r7
 228:main.c        **** 
 505               	.LM32:
 506 00de 62E0      		ldi r22,lo8(2)
 507 00e0 80E0      		ldi r24,lo8(i2c_buf)
 508 00e2 90E0      		ldi r25,hi8(i2c_buf)
 509 00e4 0E94 0000 		call TWI_Start_Transceiver_With_Data
 511               	.LM33:
 512 00e8 6092 0000 		sts i2c_buf,r6
 232:main.c        ****     TWI_Start_Transceiver_With_Data(i2c_buf, 7);
 514               	.LM34:
 515 00ec 67E0      		ldi r22,lo8(7)
 516 00ee 80E0      		ldi r24,lo8(i2c_buf)
 517 00f0 90E0      		ldi r25,hi8(i2c_buf)
 518 00f2 0E94 0000 		call TWI_Start_Transceiver_With_Data
 233:main.c        ****     TWI_Get_Data_From_Transceiver(i2c_buf,7);
 520               	.LM35:
 521 00f6 67E0      		ldi r22,lo8(7)
 522 00f8 80E0      		ldi r24,lo8(i2c_buf)
 523 00fa 90E0      		ldi r25,hi8(i2c_buf)
 524 00fc 0E94 0000 		call TWI_Get_Data_From_Transceiver
 525               	.L4:
 526 0100 F801      		movw r30,r16
 527 0102 E050      		subi r30,lo8(-(i2c_buf-13))
 528 0104 F040      		sbci r31,hi8(-(i2c_buf-13))
 234:main.c        ****     for (count = 0; count < HMC5843_SIZE; count++){
 235:main.c        ****       tx_buf[i++] = i2c_buf[count+1];
 530               	.LM36:
 531 0106 8081      		ld r24,Z
 532 0108 F801      		movw r30,r16
 533 010a E050      		subi r30,lo8(-(tx_buf))
 534 010c F040      		sbci r31,hi8(-(tx_buf))
 535 010e 8083      		st Z,r24
 536 0110 0F5F      		subi r16,-1
 537 0112 1F4F      		sbci r17,-1
 234:main.c        ****     for (count = 0; count < HMC5843_SIZE; count++){
 539               	.LM37:
 540 0114 0431      		cpi r16,20
 541 0116 1105      		cpc r17,__zero_reg__
 542 0118 01F4      		brne .L4
 236:main.c        ****     }
 237:main.c        ****     tx_len = i;
 544               	.LM38:
 545 011a 84E1      		ldi r24,lo8(20)
 546 011c 8093 0000 		sts tx_len,r24
 547 0120 E0E0      		ldi r30,lo8(tx_buf)
 548 0122 F0E0      		ldi r31,hi8(tx_buf)
 549 0124 A0E0      		ldi r26,lo8(pkt)
 550 0126 B0E0      		ldi r27,hi8(pkt)
 551               	.L5:
 552               	.LBB2:
 238:main.c        ****     packetReady = false;
 239:main.c        ****     //so we can resubmit while we build the new packet
 240:main.c        ****     for (int i = 0; i < tx_len; i++){
 554               	.LM39:
 555 0128 80E0      		ldi r24,hi8(tx_buf+20)
 556 012a E030      		cpi r30,lo8(tx_buf+20)
 557 012c F807      		cpc r31,r24
 558 012e 01F0      		breq .L12
 241:main.c        ****       pkt[i] = tx_buf[i];
 560               	.LM40:
 561 0130 8191      		ld r24,Z+
 562 0132 8D93      		st X+,r24
 563 0134 00C0      		rjmp .L5
 564               	.L12:
 565               	.LBE2:
 242:main.c        ****     }
 243:main.c        ****     packetReady = true;
 567               	.LM41:
 568 0136 81E0      		ldi r24,lo8(1)
 569 0138 8093 0000 		sts packetReady,r24
 244:main.c        ****     nrk_wait_until_next_period();
 571               	.LM42:
 572 013c 0E94 0000 		call nrk_wait_until_next_period
 245:main.c        ****   }
 574               	.LM43:
 575 0140 00C0      		rjmp .L7
 577               	.Lscope1:
 579               		.stabd	78,0,0
 580               		.section	.rodata.str1.1,"aMS",@progbits,1
 581               	.LC0:
 582 0000 5478 2054 		.string	"Tx Task PID=%u\r\n"
 582      6173 6B20 
 582      5049 443D 
 582      2575 0D0A 
 582      00
 583               		.text
 585               	.global	tx_task
 587               	tx_task:
 588               		.stabd	46,0,0
 246:main.c        **** }
 247:main.c        **** 
 248:main.c        **** 
 249:main.c        **** void tx_task ()
 250:main.c        **** {
 590               	.LM44:
 591               	.LFBB2:
 592 0142 CF93      		push r28
 593 0144 DF93      		push r29
 594 0146 CDB7      		in r28,__SP_L__
 595 0148 DEB7      		in r29,__SP_H__
 596 014a 2897      		sbiw r28,8
 597 014c 0FB6      		in __tmp_reg__,__SREG__
 598 014e F894      		cli
 599 0150 DEBF      		out __SP_H__,r29
 600 0152 0FBE      		out __SREG__,__tmp_reg__
 601 0154 CDBF      		out __SP_L__,r28
 602               	/* prologue: function */
 603               	/* frame size = 8 */
 604               	/* stack size = 10 */
 605               	.L__stack_usage = 10
 251:main.c        ****   int8_t v;
 252:main.c        ****   uint8_t cnt;
 253:main.c        ****   nrk_time_t t;
 254:main.c        **** 
 255:main.c        **** 
 256:main.c        ****   printf ("Tx Task PID=%u\r\n", nrk_get_pid ());
 607               	.LM45:
 608 0156 0E94 0000 		call nrk_get_pid
 609 015a 1F92      		push __zero_reg__
 610 015c 8F93      		push r24
 611 015e 80E0      		ldi r24,lo8(.LC0)
 612 0160 90E0      		ldi r25,hi8(.LC0)
 613 0162 9F93      		push r25
 614 0164 8F93      		push r24
 615 0166 0E94 0000 		call printf
 257:main.c        ****   t.secs = 5;
 617               	.LM46:
 618 016a 85E0      		ldi r24,lo8(5)
 619 016c 90E0      		ldi r25,0
 620 016e A0E0      		ldi r26,0
 621 0170 B0E0      		ldi r27,0
 622 0172 8983      		std Y+1,r24
 623 0174 9A83      		std Y+2,r25
 624 0176 AB83      		std Y+3,r26
 625 0178 BC83      		std Y+4,r27
 258:main.c        ****   t.nano_secs = 0;
 627               	.LM47:
 628 017a 1D82      		std Y+5,__zero_reg__
 629 017c 1E82      		std Y+6,__zero_reg__
 630 017e 1F82      		std Y+7,__zero_reg__
 631 0180 1886      		std Y+8,__zero_reg__
 259:main.c        **** 
 260:main.c        ****   // // setup a software watch dog timer
 261:main.c        ****   nrk_sw_wdt_init(0, &t, NULL);
 633               	.LM48:
 634 0182 40E0      		ldi r20,0
 635 0184 50E0      		ldi r21,0
 636 0186 BE01      		movw r22,r28
 637 0188 6F5F      		subi r22,-1
 638 018a 7F4F      		sbci r23,-1
 639 018c 80E0      		ldi r24,0
 640 018e 90E0      		ldi r25,0
 641 0190 0E94 0000 		call nrk_sw_wdt_init
 262:main.c        ****   nrk_sw_wdt_start(0);
 643               	.LM49:
 644 0194 80E0      		ldi r24,0
 645 0196 90E0      		ldi r25,0
 646 0198 0E94 0000 		call nrk_sw_wdt_start
 263:main.c        **** 
 264:main.c        **** 
 265:main.c        ****   while (!tdma_started())
 648               	.LM50:
 649 019c 0F90      		pop __tmp_reg__
 650 019e 0F90      		pop __tmp_reg__
 651 01a0 0F90      		pop __tmp_reg__
 652 01a2 0F90      		pop __tmp_reg__
 653               	.L14:
 654 01a4 0E94 0000 		call tdma_started
 655 01a8 8111      		cpse r24,__zero_reg__
 656 01aa 00C0      		rjmp .L16
 266:main.c        ****     nrk_wait_until_next_period ();
 658               	.LM51:
 659 01ac 0E94 0000 		call nrk_wait_until_next_period
 660 01b0 00C0      		rjmp .L14
 661               	.L20:
 662               	.LBB3:
 267:main.c        **** 
 268:main.c        ****   cnt = 0;
 269:main.c        **** 
 270:main.c        ****   while (1) {
 271:main.c        ****     // Update watchdog timer
 272:main.c        ****     nrk_sw_wdt_update(0);
 273:main.c        ****     nrk_led_set(RED_LED);
 274:main.c        **** 
 275:main.c        ****     // if sensor data hasn't been gathered yet
 276:main.c        ****     if (!packetReady){
 277:main.c        ****        continue;
 278:main.c        ****     }
 279:main.c        ****     nrk_led_clr(RED_LED);
 664               	.LM52:
 665 01b2 80E0      		ldi r24,0
 666 01b4 90E0      		ldi r25,0
 667 01b6 0E94 0000 		call nrk_led_clr
 280:main.c        ****     v = tdma_send (&tx_tdma_fd, &pkt, tx_len, TDMA_BLOCKING);
 669               	.LM53:
 670 01ba 20E0      		ldi r18,0
 671 01bc 4091 0000 		lds r20,tx_len
 672 01c0 60E0      		ldi r22,lo8(pkt)
 673 01c2 70E0      		ldi r23,hi8(pkt)
 674 01c4 80E0      		ldi r24,lo8(tx_tdma_fd)
 675 01c6 90E0      		ldi r25,hi8(tx_tdma_fd)
 676 01c8 0E94 0000 		call tdma_send
 281:main.c        ****     v = tdma_send (&tx_tdma_fd, &pkt, tx_len, TDMA_BLOCKING);
 678               	.LM54:
 679 01cc 20E0      		ldi r18,0
 680 01ce 4091 0000 		lds r20,tx_len
 681 01d2 60E0      		ldi r22,lo8(pkt)
 682 01d4 70E0      		ldi r23,hi8(pkt)
 683 01d6 80E0      		ldi r24,lo8(tx_tdma_fd)
 684 01d8 90E0      		ldi r25,hi8(tx_tdma_fd)
 685 01da 0E94 0000 		call tdma_send
 282:main.c        ****     v = tdma_send (&tx_tdma_fd, &pkt, tx_len, TDMA_BLOCKING);
 687               	.LM55:
 688 01de 20E0      		ldi r18,0
 689 01e0 4091 0000 		lds r20,tx_len
 690 01e4 60E0      		ldi r22,lo8(pkt)
 691 01e6 70E0      		ldi r23,hi8(pkt)
 692 01e8 80E0      		ldi r24,lo8(tx_tdma_fd)
 693 01ea 90E0      		ldi r25,hi8(tx_tdma_fd)
 694 01ec 0E94 0000 		call tdma_send
 695               	.L16:
 272:main.c        ****     nrk_led_set(RED_LED);
 697               	.LM56:
 698 01f0 80E0      		ldi r24,0
 699 01f2 90E0      		ldi r25,0
 700 01f4 0E94 0000 		call nrk_sw_wdt_update
 273:main.c        **** 
 702               	.LM57:
 703 01f8 80E0      		ldi r24,0
 704 01fa 90E0      		ldi r25,0
 705 01fc 0E94 0000 		call nrk_led_set
 276:main.c        ****        continue;
 707               	.LM58:
 708 0200 8091 0000 		lds r24,packetReady
 709 0204 8823      		tst r24
 710 0206 01F0      		breq .L16
 711 0208 00C0      		rjmp .L20
 712               	.LBE3:
 717               	.Lscope2:
 719               		.stabd	78,0,0
 721               	.global	init_itg3200
 723               	init_itg3200:
 724               		.stabd	46,0,0
 145:main.c        ****     /* put in standby mode while we change fifo control bits */
 726               	.LM59:
 727               	.LFBB3:
 728               	/* prologue: function */
 729               	/* frame size = 0 */
 730               	/* stack size = 0 */
 731               	.L__stack_usage = 0
 147:main.c        ****   i2c_buf[1] = ITG3200_REGISTER_DLPF;
 733               	.LM60:
 734 020a E0E0      		ldi r30,lo8(i2c_buf)
 735 020c F0E0      		ldi r31,hi8(i2c_buf)
 736 020e 80ED      		ldi r24,lo8(-48)
 737 0210 8083      		st Z,r24
 148:main.c        ****   i2c_buf[2] = ITG3200_FULLSCALE | ITG3200_42HZ;
 739               	.LM61:
 740 0212 86E1      		ldi r24,lo8(22)
 741 0214 8183      		std Z+1,r24
 149:main.c        ****   TWI_Start_Transceiver_With_Data(i2c_buf, 3);
 743               	.LM62:
 744 0216 8BE1      		ldi r24,lo8(27)
 745 0218 8283      		std Z+2,r24
 150:main.c        **** }
 747               	.LM63:
 748 021a 63E0      		ldi r22,lo8(3)
 749 021c CF01      		movw r24,r30
 750 021e 0C94 0000 		jmp TWI_Start_Transceiver_With_Data
 752               	.Lscope3:
 754               		.stabd	78,0,0
 756               	.global	init_hmc5843
 758               	init_hmc5843:
 759               		.stabd	46,0,0
 153:main.c        ****     /* put in standby mode while we change fifo control bits */
 761               	.LM64:
 762               	.LFBB4:
 763               	/* prologue: function */
 764               	/* frame size = 0 */
 765               	/* stack size = 0 */
 766               	.L__stack_usage = 0
 155:main.c        ****   i2c_buf[1] = HMC5843_REGISTER_MEASMODE;
 768               	.LM65:
 769 0222 E0E0      		ldi r30,lo8(i2c_buf)
 770 0224 F0E0      		ldi r31,hi8(i2c_buf)
 771 0226 8CE3      		ldi r24,lo8(60)
 772 0228 8083      		st Z,r24
 156:main.c        ****   i2c_buf[2] = HMC5843_MEASMODE_CONT;
 774               	.LM66:
 775 022a 82E0      		ldi r24,lo8(2)
 776 022c 8183      		std Z+1,r24
 157:main.c        ****   TWI_Start_Transceiver_With_Data(i2c_buf, 3);
 778               	.LM67:
 779 022e 1282      		std Z+2,__zero_reg__
 158:main.c        **** }
 781               	.LM68:
 782 0230 63E0      		ldi r22,lo8(3)
 783 0232 CF01      		movw r24,r30
 784 0234 0C94 0000 		jmp TWI_Start_Transceiver_With_Data
 786               	.Lscope4:
 788               		.stabd	78,0,0
 790               	.global	init_adxl345
 792               	init_adxl345:
 793               		.stabd	46,0,0
 162:main.c        ****   unsigned int read = 0;
 795               	.LM69:
 796               	.LFBB5:
 797 0238 0F93      		push r16
 798 023a 1F93      		push r17
 799 023c CF93      		push r28
 800 023e DF93      		push r29
 801               	/* prologue: function */
 802               	/* frame size = 0 */
 803               	/* stack size = 4 */
 804               	.L__stack_usage = 4
 166:main.c        ****   i2c_buf[1] = ADXL_REGISTER_PWRCTL;
 806               	.LM70:
 807 0240 C0E0      		ldi r28,lo8(i2c_buf)
 808 0242 D0E0      		ldi r29,hi8(i2c_buf)
 809 0244 16EA      		ldi r17,lo8(-90)
 810 0246 1883      		st Y,r17
 167:main.c        ****   i2c_buf[2] = ADXL_PWRCTL_STBY;
 812               	.LM71:
 813 0248 0DE2      		ldi r16,lo8(45)
 814 024a 0983      		std Y+1,r16
 168:main.c        ****   TWI_Start_Transceiver_With_Data(i2c_buf, 3);
 816               	.LM72:
 817 024c 1A82      		std Y+2,__zero_reg__
 169:main.c        **** 
 819               	.LM73:
 820 024e 63E0      		ldi r22,lo8(3)
 821 0250 CE01      		movw r24,r28
 822 0252 0E94 0000 		call TWI_Start_Transceiver_With_Data
 172:main.c        ****   i2c_buf[1] = ADXL_REGISTER_FIFOCTL;
 824               	.LM74:
 825 0256 1883      		st Y,r17
 173:main.c        ****   i2c_buf[2] = ADXL_FIFOCTL_STREAM;
 827               	.LM75:
 828 0258 88E3      		ldi r24,lo8(56)
 829 025a 8983      		std Y+1,r24
 174:main.c        ****   TWI_Start_Transceiver_With_Data(i2c_buf,3);
 831               	.LM76:
 832 025c 80E8      		ldi r24,lo8(-128)
 833 025e 8A83      		std Y+2,r24
 175:main.c        **** 
 835               	.LM77:
 836 0260 63E0      		ldi r22,lo8(3)
 837 0262 CE01      		movw r24,r28
 838 0264 0E94 0000 		call TWI_Start_Transceiver_With_Data
 178:main.c        ****   i2c_buf[1] = ADXL_REGISTER_DTFMT;
 840               	.LM78:
 841 0268 1883      		st Y,r17
 179:main.c        ****   i2c_buf[2] = ADXL_16G_DTFMT;
 843               	.LM79:
 844 026a 81E3      		ldi r24,lo8(49)
 845 026c 8983      		std Y+1,r24
 180:main.c        ****   TWI_Start_Transceiver_With_Data(i2c_buf,3);
 847               	.LM80:
 848 026e 8FE0      		ldi r24,lo8(15)
 849 0270 8A83      		std Y+2,r24
 181:main.c        **** 
 851               	.LM81:
 852 0272 63E0      		ldi r22,lo8(3)
 853 0274 CE01      		movw r24,r28
 854 0276 0E94 0000 		call TWI_Start_Transceiver_With_Data
 184:main.c        ****   i2c_buf[1] = ADXL_REGISTER_PWRCTL;
 856               	.LM82:
 857 027a 1883      		st Y,r17
 185:main.c        ****   i2c_buf[2] = ADXL_PWRCTL_MEASURE;
 859               	.LM83:
 860 027c 0983      		std Y+1,r16
 186:main.c        ****   TWI_Start_Transceiver_With_Data(i2c_buf, 3);
 862               	.LM84:
 863 027e 88E0      		ldi r24,lo8(8)
 864 0280 8A83      		std Y+2,r24
 187:main.c        **** }
 866               	.LM85:
 867 0282 63E0      		ldi r22,lo8(3)
 868 0284 CE01      		movw r24,r28
 869               	/* epilogue start */
 188:main.c        **** 
 871               	.LM86:
 872 0286 DF91      		pop r29
 873 0288 CF91      		pop r28
 874 028a 1F91      		pop r17
 875 028c 0F91      		pop r16
 187:main.c        **** }
 877               	.LM87:
 878 028e 0C94 0000 		jmp TWI_Start_Transceiver_With_Data
 880               	.Lscope5:
 882               		.stabd	78,0,0
 884               	.global	nrk_create_taskset
 886               	nrk_create_taskset:
 887               		.stabd	46,0,0
 283:main.c        ****     }
 284:main.c        **** }
 285:main.c        **** 
 286:main.c        **** 
 287:main.c        **** 
 288:main.c        **** void
 289:main.c        **** nrk_create_taskset()
 290:main.c        **** {
 889               	.LM88:
 890               	.LFBB6:
 891 0292 CF92      		push r12
 892 0294 DF92      		push r13
 893 0296 EF92      		push r14
 894 0298 FF92      		push r15
 895 029a CF93      		push r28
 896               	/* prologue: function */
 897               	/* frame size = 0 */
 898               	/* stack size = 5 */
 899               	.L__stack_usage = 5
 291:main.c        ****   nrk_task_set_entry_function( &TaskOne, task_imu);
 901               	.LM89:
 902 029c 60E0      		ldi r22,lo8(gs(task_imu))
 903 029e 70E0      		ldi r23,hi8(gs(task_imu))
 904 02a0 80E0      		ldi r24,lo8(TaskOne)
 905 02a2 90E0      		ldi r25,hi8(TaskOne)
 906 02a4 0E94 0000 		call nrk_task_set_entry_function
 292:main.c        ****   nrk_task_set_stk( &TaskOne, Stack1, NRK_APP_STACKSIZE);
 908               	.LM90:
 909 02a8 40E8      		ldi r20,lo8(-128)
 910 02aa 50E0      		ldi r21,0
 911 02ac 60E0      		ldi r22,lo8(Stack1)
 912 02ae 70E0      		ldi r23,hi8(Stack1)
 913 02b0 80E0      		ldi r24,lo8(TaskOne)
 914 02b2 90E0      		ldi r25,hi8(TaskOne)
 915 02b4 0E94 0000 		call nrk_task_set_stk
 293:main.c        ****   TaskOne.prio = 1;
 917               	.LM91:
 918 02b8 E0E0      		ldi r30,lo8(TaskOne)
 919 02ba F0E0      		ldi r31,hi8(TaskOne)
 920 02bc C1E0      		ldi r28,lo8(1)
 921 02be C087      		std Z+8,r28
 294:main.c        ****   TaskOne.FirstActivation = TRUE;
 923               	.LM92:
 924 02c0 C783      		std Z+7,r28
 295:main.c        ****   TaskOne.Type = BASIC_TASK;
 926               	.LM93:
 927 02c2 C187      		std Z+9,r28
 296:main.c        ****   TaskOne.SchType = PREEMPTIVE;
 929               	.LM94:
 930 02c4 C287      		std Z+10,r28
 297:main.c        ****   TaskOne.period.secs = 0;
 932               	.LM95:
 933 02c6 1386      		std Z+11,__zero_reg__
 934 02c8 1486      		std Z+12,__zero_reg__
 935 02ca 1586      		std Z+13,__zero_reg__
 936 02cc 1686      		std Z+14,__zero_reg__
 298:main.c        ****   TaskOne.period.nano_secs = 25 * NANOS_PER_MS;
 938               	.LM96:
 939 02ce 80E4      		ldi r24,lo8(64)
 940 02d0 98E7      		ldi r25,lo8(120)
 941 02d2 ADE7      		ldi r26,lo8(125)
 942 02d4 B1E0      		ldi r27,lo8(1)
 943 02d6 8787      		std Z+15,r24
 944 02d8 908B      		std Z+16,r25
 945 02da A18B      		std Z+17,r26
 946 02dc B28B      		std Z+18,r27
 299:main.c        ****   TaskOne.cpu_reserve.secs = 0;
 948               	.LM97:
 949 02de 138A      		std Z+19,__zero_reg__
 950 02e0 148A      		std Z+20,__zero_reg__
 951 02e2 158A      		std Z+21,__zero_reg__
 952 02e4 168A      		std Z+22,__zero_reg__
 300:main.c        ****   TaskOne.cpu_reserve.nano_secs = 0;
 954               	.LM98:
 955 02e6 178A      		std Z+23,__zero_reg__
 956 02e8 108E      		std Z+24,__zero_reg__
 957 02ea 118E      		std Z+25,__zero_reg__
 958 02ec 128E      		std Z+26,__zero_reg__
 301:main.c        ****   TaskOne.offset.secs = 1;
 960               	.LM99:
 961 02ee C12C      		mov r12,__zero_reg__
 962 02f0 D12C      		mov r13,__zero_reg__
 963 02f2 7601      		movw r14,r12
 964 02f4 C394      		inc r12
 965 02f6 C38E      		std Z+27,r12
 966 02f8 D48E      		std Z+28,r13
 967 02fa E58E      		std Z+29,r14
 968 02fc F68E      		std Z+30,r15
 302:main.c        ****   TaskOne.offset.nano_secs= 0;
 970               	.LM100:
 971 02fe 178E      		std Z+31,__zero_reg__
 972 0300 10A2      		std Z+32,__zero_reg__
 973 0302 11A2      		std Z+33,__zero_reg__
 974 0304 12A2      		std Z+34,__zero_reg__
 303:main.c        ****   nrk_activate_task (&TaskOne);
 976               	.LM101:
 977 0306 CF01      		movw r24,r30
 978 0308 0E94 0000 		call nrk_activate_task
 304:main.c        **** 
 305:main.c        ****   nrk_task_set_entry_function (&tx_task_info, tx_task);
 980               	.LM102:
 981 030c 60E0      		ldi r22,lo8(gs(tx_task))
 982 030e 70E0      		ldi r23,hi8(gs(tx_task))
 983 0310 80E0      		ldi r24,lo8(tx_task_info)
 984 0312 90E0      		ldi r25,hi8(tx_task_info)
 985 0314 0E94 0000 		call nrk_task_set_entry_function
 306:main.c        ****   nrk_task_set_stk (&tx_task_info, tx_task_stack, NRK_APP_STACKSIZE);
 987               	.LM103:
 988 0318 40E8      		ldi r20,lo8(-128)
 989 031a 50E0      		ldi r21,0
 990 031c 60E0      		ldi r22,lo8(tx_task_stack)
 991 031e 70E0      		ldi r23,hi8(tx_task_stack)
 992 0320 80E0      		ldi r24,lo8(tx_task_info)
 993 0322 90E0      		ldi r25,hi8(tx_task_info)
 994 0324 0E94 0000 		call nrk_task_set_stk
 307:main.c        ****   tx_task_info.prio = 1;
 996               	.LM104:
 997 0328 E0E0      		ldi r30,lo8(tx_task_info)
 998 032a F0E0      		ldi r31,hi8(tx_task_info)
 999 032c C087      		std Z+8,r28
 308:main.c        ****   tx_task_info.FirstActivation = TRUE;
 1001               	.LM105:
 1002 032e C783      		std Z+7,r28
 309:main.c        ****   tx_task_info.Type = BASIC_TASK;
 1004               	.LM106:
 1005 0330 C187      		std Z+9,r28
 310:main.c        ****   tx_task_info.SchType = PREEMPTIVE;
 1007               	.LM107:
 1008 0332 C287      		std Z+10,r28
 311:main.c        ****   tx_task_info.period.secs = 0;
 1010               	.LM108:
 1011 0334 1386      		std Z+11,__zero_reg__
 1012 0336 1486      		std Z+12,__zero_reg__
 1013 0338 1586      		std Z+13,__zero_reg__
 1014 033a 1686      		std Z+14,__zero_reg__
 312:main.c        ****   tx_task_info.period.nano_secs = 0 * NANOS_PER_MS;
 1016               	.LM109:
 1017 033c 1786      		std Z+15,__zero_reg__
 1018 033e 108A      		std Z+16,__zero_reg__
 1019 0340 118A      		std Z+17,__zero_reg__
 1020 0342 128A      		std Z+18,__zero_reg__
 313:main.c        ****   tx_task_info.cpu_reserve.secs = 0;
 1022               	.LM110:
 1023 0344 138A      		std Z+19,__zero_reg__
 1024 0346 148A      		std Z+20,__zero_reg__
 1025 0348 158A      		std Z+21,__zero_reg__
 1026 034a 168A      		std Z+22,__zero_reg__
 314:main.c        ****   tx_task_info.cpu_reserve.nano_secs = 0 * NANOS_PER_MS;
 1028               	.LM111:
 1029 034c 178A      		std Z+23,__zero_reg__
 1030 034e 108E      		std Z+24,__zero_reg__
 1031 0350 118E      		std Z+25,__zero_reg__
 1032 0352 128E      		std Z+26,__zero_reg__
 315:main.c        ****   tx_task_info.offset.secs = 1;
 1034               	.LM112:
 1035 0354 C38E      		std Z+27,r12
 1036 0356 D48E      		std Z+28,r13
 1037 0358 E58E      		std Z+29,r14
 1038 035a F68E      		std Z+30,r15
 316:main.c        ****   tx_task_info.offset.nano_secs = 0;
 1040               	.LM113:
 1041 035c 178E      		std Z+31,__zero_reg__
 1042 035e 10A2      		std Z+32,__zero_reg__
 1043 0360 11A2      		std Z+33,__zero_reg__
 1044 0362 12A2      		std Z+34,__zero_reg__
 317:main.c        ****   nrk_activate_task (&tx_task_info);
 1046               	.LM114:
 1047 0364 CF01      		movw r24,r30
 1048 0366 0E94 0000 		call nrk_activate_task
 1049               	/* epilogue start */
 318:main.c        **** 
 319:main.c        ****   tdma_task_config ();
 320:main.c        **** }
 1051               	.LM115:
 1052 036a CF91      		pop r28
 1053 036c FF90      		pop r15
 1054 036e EF90      		pop r14
 1055 0370 DF90      		pop r13
 1056 0372 CF90      		pop r12
 319:main.c        **** }
 1058               	.LM116:
 1059 0374 0C94 0000 		jmp tdma_task_config
 1061               	.Lscope6:
 1063               		.stabd	78,0,0
 1064               		.section	.rodata.str1.1
 1065               	.LC1:
 1066 0011 6D61 6320 		.string	"mac = %d\r\n"
 1066      3D20 2564 
 1066      0D0A 00
 1067               		.section	.text.startup,"ax",@progbits
 1069               	.global	main
 1071               	main:
 1072               		.stabd	46,0,0
 106:main.c        **** 
 1074               	.LM117:
 1075               	.LFBB7:
 1076               	/* prologue: function */
 1077               	/* frame size = 0 */
 1078               	/* stack size = 0 */
 1079               	.L__stack_usage = 0
 108:main.c        ****   nrk_setup_uart(UART_BAUDRATE_115K2);
 1081               	.LM118:
 1082 0000 0E94 0000 		call nrk_setup_ports
 109:main.c        ****   nrk_init();
 1084               	.LM119:
 1085 0004 80E1      		ldi r24,lo8(16)
 1086 0006 90E0      		ldi r25,0
 1087 0008 0E94 0000 		call nrk_setup_uart
 110:main.c        **** 
 1089               	.LM120:
 1090 000c 0E94 0000 		call nrk_init
 112:main.c        ****   sei();
 1092               	.LM121:
 1093 0010 0E94 0000 		call TWI_Master_Initialise
 113:main.c        ****   init_adxl345();
 1095               	.LM122:
 1096               	/* #APP */
 1097               	 ;  113 "main.c" 1
 1098 0014 7894      		sei
 1099               	 ;  0 "" 2
 114:main.c        ****   init_itg3200();
 1101               	.LM123:
 1102               	/* #NOAPP */
 1103 0016 0E94 0000 		call init_adxl345
 115:main.c        ****   init_hmc5843();
 1105               	.LM124:
 1106 001a 0E94 0000 		call init_itg3200
 116:main.c        ****   /* initialize sequence number, used to sync with master */
 1108               	.LM125:
 1109 001e 0E94 0000 		call init_hmc5843
 118:main.c        **** 
 1111               	.LM126:
 1112 0022 1092 0000 		sts sequenceNo+1,__zero_reg__
 1113 0026 1092 0000 		sts sequenceNo,__zero_reg__
 121:main.c        ****   
 1115               	.LM127:
 1116 002a 1092 0000 		sts packetReady,__zero_reg__
 124:main.c        ****   printf("mac = %d\r\n",mac_address);
 1118               	.LM128:
 1119 002e 82E0      		ldi r24,lo8(2)
 1120 0030 90E0      		ldi r25,0
 1121 0032 9093 0000 		sts mac_address+1,r25
 1122 0036 8093 0000 		sts mac_address,r24
 125:main.c        ****   tdma_init (TDMA_CLIENT, DEFAULT_CHANNEL, CLIENT_MAC);
 1124               	.LM129:
 1125 003a 1F92      		push __zero_reg__
 1126 003c 8F93      		push r24
 1127 003e 80E0      		ldi r24,lo8(.LC1)
 1128 0040 90E0      		ldi r25,hi8(.LC1)
 1129 0042 9F93      		push r25
 1130 0044 8F93      		push r24
 1131 0046 0E94 0000 		call printf
 126:main.c        **** 
 1133               	.LM130:
 1134 004a 42E0      		ldi r20,lo8(2)
 1135 004c 50E0      		ldi r21,0
 1136 004e 6DE0      		ldi r22,lo8(13)
 1137 0050 82E0      		ldi r24,lo8(2)
 1138 0052 0E94 0000 		call tdma_init
 131:main.c        **** 
 1140               	.LM131:
 1141 0056 8091 0000 		lds r24,mac_address
 1142 005a 9091 0000 		lds r25,mac_address+1
 1143 005e 0E94 0000 		call tdma_tx_slot_add
 133:main.c        ****   nrk_led_clr(BLUE_LED);
 1145               	.LM132:
 1146 0062 82E0      		ldi r24,lo8(2)
 1147 0064 90E0      		ldi r25,0
 1148 0066 0E94 0000 		call nrk_led_clr
 134:main.c        ****   nrk_led_clr(GREEN_LED);
 1150               	.LM133:
 1151 006a 83E0      		ldi r24,lo8(3)
 1152 006c 90E0      		ldi r25,0
 1153 006e 0E94 0000 		call nrk_led_clr
 135:main.c        ****   nrk_led_clr(RED_LED);
 1155               	.LM134:
 1156 0072 81E0      		ldi r24,lo8(1)
 1157 0074 90E0      		ldi r25,0
 1158 0076 0E94 0000 		call nrk_led_clr
 136:main.c        ****  
 1160               	.LM135:
 1161 007a 80E0      		ldi r24,0
 1162 007c 90E0      		ldi r25,0
 1163 007e 0E94 0000 		call nrk_led_clr
 138:main.c        ****   nrk_create_taskset();
 1165               	.LM136:
 1166 0082 20E0      		ldi r18,0
 1167 0084 30E0      		ldi r19,0
 1168 0086 A901      		movw r20,r18
 1169 0088 60E0      		ldi r22,0
 1170 008a 70E0      		ldi r23,0
 1171 008c CB01      		movw r24,r22
 1172 008e 0E94 0000 		call nrk_time_set
 139:main.c        ****   nrk_start();
 1174               	.LM137:
 1175 0092 0E94 0000 		call nrk_create_taskset
 140:main.c        ****   
 1177               	.LM138:
 1178 0096 0E94 0000 		call nrk_start
 1179 009a 0F90      		pop __tmp_reg__
 1180 009c 0F90      		pop __tmp_reg__
 1181 009e 0F90      		pop __tmp_reg__
 1182 00a0 0F90      		pop __tmp_reg__
 143:main.c        **** 
 1184               	.LM139:
 1185 00a2 80E0      		ldi r24,0
 1186 00a4 90E0      		ldi r25,0
 1187 00a6 0895      		ret
 1189               	.Lscope7:
 1191               		.stabd	78,0,0
 1192               		.comm	tx_task_info,35,1
 1193               		.comm	tx_task_stack,128,1
 1194               		.comm	rx_task_info,35,1
 1195               		.comm	rx_task_stack,128,1
 1196               		.comm	TaskOne,35,1
 1197               		.comm	Stack1,128,1
 1198               	.global	aes_key
 1199               		.data
 1202               	aes_key:
 1203 0000 00        		.byte	0
 1204 0001 11        		.byte	17
 1205 0002 22        		.byte	34
 1206 0003 33        		.byte	51
 1207 0004 44        		.byte	68
 1208 0005 55        		.byte	85
 1209 0006 66        		.byte	102
 1210 0007 77        		.byte	119
 1211 0008 88        		.byte	-120
 1212 0009 99        		.byte	-103
 1213 000a AA        		.byte	-86
 1214 000b BB        		.byte	-69
 1215 000c CC        		.byte	-52
 1216 000d DD        		.byte	-35
 1217 000e EE        		.byte	-18
 1218 000f FF        		.byte	-1
 1219               		.comm	mac_address,2,1
 1220               		.comm	packetReady,1,1
 1221               		.comm	sequenceNo,2,1
 1222               		.comm	tx_len,1,1
 1223               		.comm	pkt,112,1
 1224               		.comm	tx_buf,112,1
 1225               		.comm	i2c_buf,16,1
 1226               		.comm	rx_tdma_fd,18,1
 1227               		.comm	tx_tdma_fd,18,1
 1228               		.comm	tdma_rfTxInfo,7,1
 1229               		.comm	tdma_rfRxInfo,12,1
 1230               		.comm	tdma_enable_signal,1,1
 1231               		.comm	tdma_tx_pkt_done_signal,1,1
 1232               		.comm	tdma_rx_pkt_signal,1,1
 1233               		.comm	_nrk_stats_sleep_time,8,1
 1234               		.comm	cur_task_stats,120,1
 1235               		.comm	app_timer0_prescale,1,1
 1236               		.comm	app_timer0_callback,2,1
 1237               		.comm	_nrk_time_trigger,1,1
 1238               		.comm	_nrk_prev_timer_val,1,1
 1239               		.comm	error_num,1,1
 1240               		.comm	error_task,1,1
 1241               		.comm	nrk_kernel_stk_ptr,2,1
 1242               		.comm	nrk_idle_task_stk,128,1
 1243               		.comm	_nrk_signal_list,4,1
 1276               		.text
 1278               	.Letext0:
 1279               		.ident	"GCC: (GNU) 4.9.1"
 1280               	.global __do_copy_data
 1281               	.global __do_clear_bss
DEFINED SYMBOLS
                            *ABS*:0000000000000000 main.c
/var/folders/5w/cgn1dq610yqf6q25zlv0gqm40000gn/T//ccmf8OBz.s:2      *ABS*:000000000000003e __SP_H__
/var/folders/5w/cgn1dq610yqf6q25zlv0gqm40000gn/T//ccmf8OBz.s:3      *ABS*:000000000000003d __SP_L__
/var/folders/5w/cgn1dq610yqf6q25zlv0gqm40000gn/T//ccmf8OBz.s:4      *ABS*:000000000000003f __SREG__
/var/folders/5w/cgn1dq610yqf6q25zlv0gqm40000gn/T//ccmf8OBz.s:5      *ABS*:000000000000003b __RAMPZ__
/var/folders/5w/cgn1dq610yqf6q25zlv0gqm40000gn/T//ccmf8OBz.s:6      *ABS*:0000000000000000 __tmp_reg__
/var/folders/5w/cgn1dq610yqf6q25zlv0gqm40000gn/T//ccmf8OBz.s:7      *ABS*:0000000000000001 __zero_reg__
/var/folders/5w/cgn1dq610yqf6q25zlv0gqm40000gn/T//ccmf8OBz.s:339    .text:0000000000000000 task_imu
                            *COM*:0000000000000070 tx_buf
                            *COM*:0000000000000002 sequenceNo
                            *COM*:0000000000000010 i2c_buf
                            *COM*:0000000000000001 tx_len
                            *COM*:0000000000000070 pkt
                            *COM*:0000000000000001 packetReady
/var/folders/5w/cgn1dq610yqf6q25zlv0gqm40000gn/T//ccmf8OBz.s:587    .text:0000000000000142 tx_task
                            *COM*:0000000000000012 tx_tdma_fd
/var/folders/5w/cgn1dq610yqf6q25zlv0gqm40000gn/T//ccmf8OBz.s:723    .text:000000000000020a init_itg3200
/var/folders/5w/cgn1dq610yqf6q25zlv0gqm40000gn/T//ccmf8OBz.s:758    .text:0000000000000222 init_hmc5843
/var/folders/5w/cgn1dq610yqf6q25zlv0gqm40000gn/T//ccmf8OBz.s:792    .text:0000000000000238 init_adxl345
/var/folders/5w/cgn1dq610yqf6q25zlv0gqm40000gn/T//ccmf8OBz.s:886    .text:0000000000000292 nrk_create_taskset
                            *COM*:0000000000000023 TaskOne
                            *COM*:0000000000000080 Stack1
                            *COM*:0000000000000023 tx_task_info
                            *COM*:0000000000000080 tx_task_stack
/var/folders/5w/cgn1dq610yqf6q25zlv0gqm40000gn/T//ccmf8OBz.s:1071   .text.startup:0000000000000000 main
                            *COM*:0000000000000002 mac_address
                            *COM*:0000000000000023 rx_task_info
                            *COM*:0000000000000080 rx_task_stack
/var/folders/5w/cgn1dq610yqf6q25zlv0gqm40000gn/T//ccmf8OBz.s:1202   .data:0000000000000000 aes_key
                            *COM*:0000000000000012 rx_tdma_fd
                            *COM*:0000000000000007 tdma_rfTxInfo
                            *COM*:000000000000000c tdma_rfRxInfo
                            *COM*:0000000000000001 tdma_enable_signal
                            *COM*:0000000000000001 tdma_tx_pkt_done_signal
                            *COM*:0000000000000001 tdma_rx_pkt_signal
                            *COM*:0000000000000008 _nrk_stats_sleep_time
                            *COM*:0000000000000078 cur_task_stats
                            *COM*:0000000000000001 app_timer0_prescale
                            *COM*:0000000000000002 app_timer0_callback
                            *COM*:0000000000000001 _nrk_time_trigger
                            *COM*:0000000000000001 _nrk_prev_timer_val
                            *COM*:0000000000000001 error_num
                            *COM*:0000000000000001 error_task
                            *COM*:0000000000000002 nrk_kernel_stk_ptr
                            *COM*:0000000000000080 nrk_idle_task_stk
                            *COM*:0000000000000004 _nrk_signal_list

UNDEFINED SYMBOLS
TWI_Start_Transceiver_With_Data
TWI_Get_Data_From_Transceiver
nrk_wait_until_next_period
nrk_get_pid
printf
nrk_sw_wdt_init
nrk_sw_wdt_start
tdma_started
nrk_led_clr
tdma_send
nrk_sw_wdt_update
nrk_led_set
nrk_task_set_entry_function
nrk_task_set_stk
nrk_activate_task
tdma_task_config
nrk_setup_ports
nrk_setup_uart
nrk_init
TWI_Master_Initialise
tdma_init
tdma_tx_slot_add
nrk_time_set
nrk_start
__do_copy_data
__do_clear_bss
