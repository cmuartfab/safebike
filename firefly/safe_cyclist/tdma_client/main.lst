   1               		.file	"main.c"
   2               	__SP_H__ = 0x3e
   3               	__SP_L__ = 0x3d
   4               	__SREG__ = 0x3f
   5               	__RAMPZ__ = 0x3b
   6               	__tmp_reg__ = 0
   7               	__zero_reg__ = 1
  10               		.text
  11               	.Ltext0:
 337               	.global	task_imu
 339               	task_imu:
 340               		.stabd	46,0,0
   1:main.c        **** /******************************************************************************
   2:main.c        **** *  Nano-RK, a real-time operating system for sensor networks.
   3:main.c        **** *  Copyright (C) 2007, Real-Time and Multimedia Lab, Carnegie Mellon University
   4:main.c        **** *  All rights reserved.
   5:main.c        **** *
   6:main.c        **** *  This is the Open Source Version of Nano-RK included as part of a Dual
   7:main.c        **** *  Licensing Model. If you are unsure which license to use please refer to:
   8:main.c        **** *  http://www.nanork.org/nano-RK/wiki/Licensing
   9:main.c        **** *
  10:main.c        **** *  This program is free software: you can redistribute it and/or modify
  11:main.c        **** *  it under the terms of the GNU General Public License as published by
  12:main.c        **** *  the Free Software Foundation, version 2.0 of the License.
  13:main.c        **** *
  14:main.c        **** *  This program is distributed in the hope that it will be useful,
  15:main.c        **** *  but WITHOUT ANY WARRANTY; without even the implied warranty of
  16:main.c        **** *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  17:main.c        **** *  GNU General Public License for more details.
  18:main.c        **** *
  19:main.c        **** *  You should have received a copy of the GNU General Public License
  20:main.c        **** *  along with this program.  If not, see <http://www.gnu.org/licenses/>.
  21:main.c        **** *
  22:main.c        **** *******************************************************************************/
  23:main.c        **** 
  24:main.c        **** #include <nrk.h>
  25:main.c        **** #include <include.h>
  26:main.c        **** #include <ulib.h>
  27:main.c        **** #include <stdio.h>
  28:main.c        **** #include <hal.h>
  29:main.c        **** #include <nrk_error.h>
  30:main.c        **** #include <nrk_timer.h>
  31:main.c        **** #include <nrk_stack_check.h>
  32:main.c        **** #include <nrk_stats.h>
  33:main.c        **** #include <pcf_tdma.h>
  34:main.c        **** #include <TWI_Master.h>
  35:main.c        **** #include <tdma_cons.h>
  36:main.c        **** 
  37:main.c        **** // Constants for the accelrometer
  38:main.c        **** //There are 6 data registers, they are sequential starting 
  39:main.c        **** //with the LSB of X.  We'll read all 6 in a burst and won't
  40:main.c        **** //address them individually
  41:main.c        **** #define ADXL345_REGISTER_XLSB 0x32
  42:main.c        **** #define ADXL_REGISTER_DTFMT 0x31
  43:main.c        **** //Need to set power control bit to wake up the adxl345
  44:main.c        **** #define ADXL_REGISTER_PWRCTL 0x2D
  45:main.c        **** #define ADXL_REGISTER_FIFOCTL 0x38
  46:main.c        **** #define ADXL_FIFOCTL_STREAM 1<<7
  47:main.c        **** #define ADXL_PWRCTL_MEASURE 1 << 3
  48:main.c        **** #define ADXL_16G_DTFMT 0x0F
  49:main.c        **** #define ADXL_PWRCTL_STBY 0
  50:main.c        **** #define ADXL345_ADDRESS 0xA6
  51:main.c        **** #define ADXL_SIZE 6
  52:main.c        **** 
  53:main.c        **** 
  54:main.c        **** //Constants for the gyroscope
  55:main.c        **** #define ITG3200_ADDRESS 0xD0
  56:main.c        **** //request burst of 6 bytes from this address
  57:main.c        **** #define ITG3200_REGISTER_XMSB 0x1D
  58:main.c        **** #define ITG3200_REGISTER_DLPF 0x16
  59:main.c        **** #define ITG3200_FULLSCALE 0x03 << 3
  60:main.c        **** #define ITG3200_42HZ 0x03
  61:main.c        **** #define ITG3200_SIZE 6
  62:main.c        **** 
  63:main.c        **** 
  64:main.c        **** #define HMC5843_ADDRESS 0x3C
  65:main.c        **** //First data address of 6 is XMSB.  Also need to set a configuration register for
  66:main.c        **** //continuous measurement
  67:main.c        **** #define HMC5843_REGISTER_XMSB 0x03
  68:main.c        **** #define HMC5843_REGISTER_MEASMODE 0x02
  69:main.c        **** #define HMC5843_MEASMODE_CONT 0x00
  70:main.c        **** #define HMC5843_SIZE 6
  71:main.c        **** 
  72:main.c        **** 
  73:main.c        **** tdma_info tx_tdma_fd;
  74:main.c        **** tdma_info rx_tdma_fd;
  75:main.c        **** 
  76:main.c        **** uint8_t i2c_buf[16];
  77:main.c        **** uint8_t tx_buf[TDMA_MAX_PKT_SIZE];
  78:main.c        **** uint8_t pkt[TDMA_MAX_PKT_SIZE];
  79:main.c        **** uint8_t tx_len;
  80:main.c        **** unsigned int sequenceNo; 
  81:main.c        **** bool packetReady;
  82:main.c        **** uint16_t mac_address;
  83:main.c        **** 
  84:main.c        **** uint8_t aes_key[] = {0x00,0x11,0x22,0x33,0x44,0x55,0x66,0x77,0x88,0x99,0xaa,0xbb,0xcc,0xdd,0xee, 0x
  85:main.c        **** 
  86:main.c        **** NRK_STK Stack1[NRK_APP_STACKSIZE];
  87:main.c        **** nrk_task_type TaskOne;
  88:main.c        **** void task_imu(void);
  89:main.c        **** 
  90:main.c        **** NRK_STK rx_task_stack[NRK_APP_STACKSIZE];
  91:main.c        **** nrk_task_type rx_task_info;
  92:main.c        **** void rx_task (void);
  93:main.c        **** 
  94:main.c        **** NRK_STK tx_task_stack[NRK_APP_STACKSIZE];
  95:main.c        **** nrk_task_type tx_task_info;
  96:main.c        **** void tx_task (void);
  97:main.c        **** 
  98:main.c        **** 
  99:main.c        **** void init_adxl345(void);
 100:main.c        **** void init_itg3200(void);
 101:main.c        **** void init_hmc5843(void);
 102:main.c        **** 
 103:main.c        **** void nrk_create_taskset();
 104:main.c        **** 
 105:main.c        **** int main ()
 106:main.c        **** { 
 107:main.c        **** 
 108:main.c        ****   nrk_setup_ports();
 109:main.c        ****   nrk_setup_uart(UART_BAUDRATE_115K2);
 110:main.c        ****   nrk_init();
 111:main.c        **** 
 112:main.c        ****   TWI_Master_Initialise();
 113:main.c        ****   sei();
 114:main.c        ****   init_adxl345();
 115:main.c        ****   init_itg3200();
 116:main.c        ****   init_hmc5843();
 117:main.c        ****   /* initialize sequence number, used to sync with master */
 118:main.c        ****   sequenceNo = 0; 
 119:main.c        **** 
 120:main.c        ****   /* initialize tx_buf ready flag */
 121:main.c        ****   packetReady = false;
 122:main.c        ****   
 123:main.c        **** 
 124:main.c        ****   mac_address = CLIENT_MAC;
 125:main.c        ****   printf("mac = %d\r\n",mac_address);
 126:main.c        ****   tdma_init (TDMA_CLIENT, DEFAULT_CHANNEL, CLIENT_MAC);
 127:main.c        **** 
 128:main.c        ****   //tdma_aes_setkey(aes_key);
 129:main.c        ****   //tdma_aes_enable();
 130:main.c        **** 
 131:main.c        ****   tdma_tx_slot_add (mac_address&0xFFFF);
 132:main.c        **** 
 133:main.c        ****   nrk_led_clr(ORANGE_LED);
 134:main.c        ****   nrk_led_clr(BLUE_LED);
 135:main.c        ****   nrk_led_clr(GREEN_LED);
 136:main.c        ****   nrk_led_clr(RED_LED);
 137:main.c        ****  
 138:main.c        ****   nrk_time_set(0,0);
 139:main.c        ****   nrk_create_taskset();
 140:main.c        ****   nrk_start();
 141:main.c        ****   
 142:main.c        ****   return 0;
 143:main.c        **** }
 144:main.c        **** 
 145:main.c        **** void init_itg3200() {
 146:main.c        ****     /* put in standby mode while we change fifo control bits */
 147:main.c        ****   i2c_buf[0] = ITG3200_ADDRESS | FALSE<<TWI_READ_BIT;
 148:main.c        ****   i2c_buf[1] = ITG3200_REGISTER_DLPF;
 149:main.c        ****   i2c_buf[2] = ITG3200_FULLSCALE | ITG3200_42HZ;
 150:main.c        ****   TWI_Start_Transceiver_With_Data(i2c_buf, 3);
 151:main.c        **** }
 152:main.c        **** 
 153:main.c        **** void init_hmc5843() {
 154:main.c        ****     /* put in standby mode while we change fifo control bits */
 155:main.c        ****   i2c_buf[0] = HMC5843_ADDRESS | FALSE<<TWI_READ_BIT;
 156:main.c        ****   i2c_buf[1] = HMC5843_REGISTER_MEASMODE;
 157:main.c        ****   i2c_buf[2] = HMC5843_MEASMODE_CONT;
 158:main.c        ****   TWI_Start_Transceiver_With_Data(i2c_buf, 3);
 159:main.c        **** }
 160:main.c        **** 
 161:main.c        **** 
 162:main.c        **** void init_adxl345() {
 163:main.c        ****   unsigned int read = 0;
 164:main.c        **** 
 165:main.c        ****   /* put in standby mode while we change fifo control bits */
 166:main.c        ****   i2c_buf[0] = ADXL345_ADDRESS | FALSE<<TWI_READ_BIT;
 167:main.c        ****   i2c_buf[1] = ADXL_REGISTER_PWRCTL;
 168:main.c        ****   i2c_buf[2] = ADXL_PWRCTL_STBY;
 169:main.c        ****   TWI_Start_Transceiver_With_Data(i2c_buf, 3);
 170:main.c        **** 
 171:main.c        ****   /* set the fifo mode to stream */
 172:main.c        ****   i2c_buf[0] = ADXL345_ADDRESS | FALSE<<TWI_READ_BIT;
 173:main.c        ****   i2c_buf[1] = ADXL_REGISTER_FIFOCTL;
 174:main.c        ****   i2c_buf[2] = ADXL_FIFOCTL_STREAM;
 175:main.c        ****   TWI_Start_Transceiver_With_Data(i2c_buf,3);
 176:main.c        **** 
 177:main.c        ****   /* set data format to full resolution +-16g */
 178:main.c        ****   i2c_buf[0] = ADXL345_ADDRESS | FALSE<<TWI_READ_BIT;
 179:main.c        ****   i2c_buf[1] = ADXL_REGISTER_DTFMT;
 180:main.c        ****   i2c_buf[2] = ADXL_16G_DTFMT;
 181:main.c        ****   TWI_Start_Transceiver_With_Data(i2c_buf,3);
 182:main.c        **** 
 183:main.c        ****   /* set to measure mode */
 184:main.c        ****   i2c_buf[0] = ADXL345_ADDRESS | FALSE<<TWI_READ_BIT;
 185:main.c        ****   i2c_buf[1] = ADXL_REGISTER_PWRCTL;
 186:main.c        ****   i2c_buf[2] = ADXL_PWRCTL_MEASURE;
 187:main.c        ****   TWI_Start_Transceiver_With_Data(i2c_buf, 3);
 188:main.c        **** }
 189:main.c        **** 
 190:main.c        **** void task_imu(){
 342               	.LM0:
 343               	.LFBB1:
 344               	/* prologue: function */
 345               	/* frame size = 0 */
 346               	/* stack size = 0 */
 347               	.L__stack_usage = 0
 191:main.c        ****   unsigned int i;
 192:main.c        ****   unsigned int count;
 193:main.c        ****   int v;
 194:main.c        ****   
 195:main.c        ****   while(1){
 196:main.c        ****     i = 0;
 197:main.c        ****     tx_buf[i++] = NODE_ADDR;
 349               	.LM1:
 350 0000 82E0      		ldi r24,lo8(2)
 351 0002 F82E      		mov r15,r24
 198:main.c        ****     tx_buf[i++] = sequenceNo++;
 199:main.c        ****     
 200:main.c        ****     i2c_buf[0] = (ADXL345_ADDRESS) | (FALSE<<TWI_READ_BIT);
 353               	.LM2:
 354 0004 96EA      		ldi r25,lo8(-90)
 355 0006 E92E      		mov r14,r25
 201:main.c        ****     i2c_buf[1] = ADXL345_REGISTER_XLSB;
 357               	.LM3:
 358 0008 22E3      		ldi r18,lo8(50)
 359 000a D22E      		mov r13,r18
 202:main.c        ****     TWI_Start_Transceiver_With_Data(i2c_buf, 2);
 203:main.c        **** 
 204:main.c        **** 
 205:main.c        ****     /* Read first byte */
 206:main.c        ****     i2c_buf[0] = (ADXL345_ADDRESS) | (TRUE<<TWI_READ_BIT);
 361               	.LM4:
 362 000c 37EA      		ldi r19,lo8(-89)
 363 000e C32E      		mov r12,r19
 207:main.c        **** 
 208:main.c        ****     TWI_Start_Transceiver_With_Data(i2c_buf, 7);
 209:main.c        ****     TWI_Get_Data_From_Transceiver(i2c_buf,7);
 210:main.c        ****     for (count = 0; count < ADXL_SIZE; count++){
 211:main.c        ****       tx_buf[i++] = i2c_buf[count+1];
 212:main.c        ****     }
 213:main.c        **** 
 214:main.c        ****     i2c_buf[0] = (ITG3200_ADDRESS) | (FALSE<<TWI_READ_BIT);
 365               	.LM5:
 366 0010 40ED      		ldi r20,lo8(-48)
 367 0012 B42E      		mov r11,r20
 215:main.c        ****     i2c_buf[1] = ITG3200_REGISTER_XMSB;
 369               	.LM6:
 370 0014 5DE1      		ldi r21,lo8(29)
 371 0016 A52E      		mov r10,r21
 216:main.c        ****     TWI_Start_Transceiver_With_Data(i2c_buf, 2);
 217:main.c        **** 
 218:main.c        ****     /* Read first byte */
 219:main.c        ****     i2c_buf[0] = (ITG3200_ADDRESS) | (TRUE<<TWI_READ_BIT);
 373               	.LM7:
 374 0018 61ED      		ldi r22,lo8(-47)
 375 001a 962E      		mov r9,r22
 220:main.c        ****     TWI_Start_Transceiver_With_Data(i2c_buf, 7);
 221:main.c        ****     TWI_Get_Data_From_Transceiver(i2c_buf,7);
 222:main.c        ****     for (count = 0; count < ITG3200_SIZE; count++){
 223:main.c        ****       tx_buf[i++] = i2c_buf[count+1];
 224:main.c        ****     }
 225:main.c        **** 
 226:main.c        ****     i2c_buf[0] = (HMC5843_ADDRESS) | (FALSE<<TWI_READ_BIT);
 377               	.LM8:
 378 001c 7CE3      		ldi r23,lo8(60)
 379 001e 872E      		mov r8,r23
 227:main.c        ****     i2c_buf[1] = HMC5843_REGISTER_XMSB;
 381               	.LM9:
 382 0020 E3E0      		ldi r30,lo8(3)
 383 0022 7E2E      		mov r7,r30
 228:main.c        ****     TWI_Start_Transceiver_With_Data(i2c_buf, 2);
 229:main.c        **** 
 230:main.c        ****     /* Read first byte */
 231:main.c        ****     i2c_buf[0] = (HMC5843_ADDRESS) | (TRUE<<TWI_READ_BIT);
 385               	.LM10:
 386 0024 FDE3      		ldi r31,lo8(61)
 387 0026 6F2E      		mov r6,r31
 388               	.L7:
 197:main.c        ****     tx_buf[i++] = sequenceNo++;
 390               	.LM11:
 391 0028 F092 0000 		sts tx_buf,r15
 198:main.c        ****     
 393               	.LM12:
 394 002c 8091 0000 		lds r24,sequenceNo
 395 0030 9091 0000 		lds r25,sequenceNo+1
 396 0034 9C01      		movw r18,r24
 397 0036 2F5F      		subi r18,-1
 398 0038 3F4F      		sbci r19,-1
 399 003a 3093 0000 		sts sequenceNo+1,r19
 400 003e 2093 0000 		sts sequenceNo,r18
 401 0042 8093 0000 		sts tx_buf+1,r24
 200:main.c        ****     i2c_buf[1] = ADXL345_REGISTER_XLSB;
 403               	.LM13:
 404 0046 E092 0000 		sts i2c_buf,r14
 201:main.c        ****     TWI_Start_Transceiver_With_Data(i2c_buf, 2);
 406               	.LM14:
 407 004a D092 0000 		sts i2c_buf+1,r13
 202:main.c        **** 
 409               	.LM15:
 410 004e 62E0      		ldi r22,lo8(2)
 411 0050 80E0      		ldi r24,lo8(i2c_buf)
 412 0052 90E0      		ldi r25,hi8(i2c_buf)
 413 0054 0E94 0000 		call TWI_Start_Transceiver_With_Data
 206:main.c        **** 
 415               	.LM16:
 416 0058 C092 0000 		sts i2c_buf,r12
 208:main.c        ****     TWI_Get_Data_From_Transceiver(i2c_buf,7);
 418               	.LM17:
 419 005c 67E0      		ldi r22,lo8(7)
 420 005e 80E0      		ldi r24,lo8(i2c_buf)
 421 0060 90E0      		ldi r25,hi8(i2c_buf)
 422 0062 0E94 0000 		call TWI_Start_Transceiver_With_Data
 209:main.c        ****     for (count = 0; count < ADXL_SIZE; count++){
 424               	.LM18:
 425 0066 67E0      		ldi r22,lo8(7)
 426 0068 80E0      		ldi r24,lo8(i2c_buf)
 427 006a 90E0      		ldi r25,hi8(i2c_buf)
 428 006c 0E94 0000 		call TWI_Get_Data_From_Transceiver
 198:main.c        ****     
 430               	.LM19:
 431 0070 82E0      		ldi r24,lo8(2)
 432 0072 90E0      		ldi r25,0
 433               	.L2:
 211:main.c        ****     }
 435               	.LM20:
 436 0074 EC01      		movw r28,r24
 437 0076 2196      		adiw r28,1
 438 0078 FC01      		movw r30,r24
 439 007a E050      		subi r30,lo8(-(i2c_buf-1))
 440 007c F040      		sbci r31,hi8(-(i2c_buf-1))
 441 007e 2081      		ld r18,Z
 442 0080 FC01      		movw r30,r24
 443 0082 E050      		subi r30,lo8(-(tx_buf))
 444 0084 F040      		sbci r31,hi8(-(tx_buf))
 445 0086 2083      		st Z,r18
 446 0088 CE01      		movw r24,r28
 210:main.c        ****       tx_buf[i++] = i2c_buf[count+1];
 448               	.LM21:
 449 008a C830      		cpi r28,8
 450 008c D105      		cpc r29,__zero_reg__
 451 008e 01F4      		brne .L2
 214:main.c        ****     i2c_buf[1] = ITG3200_REGISTER_XMSB;
 453               	.LM22:
 454 0090 B092 0000 		sts i2c_buf,r11
 215:main.c        ****     TWI_Start_Transceiver_With_Data(i2c_buf, 2);
 456               	.LM23:
 457 0094 A092 0000 		sts i2c_buf+1,r10
 216:main.c        **** 
 459               	.LM24:
 460 0098 62E0      		ldi r22,lo8(2)
 461 009a 80E0      		ldi r24,lo8(i2c_buf)
 462 009c 90E0      		ldi r25,hi8(i2c_buf)
 463 009e 0E94 0000 		call TWI_Start_Transceiver_With_Data
 219:main.c        ****     TWI_Start_Transceiver_With_Data(i2c_buf, 7);
 465               	.LM25:
 466 00a2 9092 0000 		sts i2c_buf,r9
 220:main.c        ****     TWI_Get_Data_From_Transceiver(i2c_buf,7);
 468               	.LM26:
 469 00a6 67E0      		ldi r22,lo8(7)
 470 00a8 80E0      		ldi r24,lo8(i2c_buf)
 471 00aa 90E0      		ldi r25,hi8(i2c_buf)
 472 00ac 0E94 0000 		call TWI_Start_Transceiver_With_Data
 221:main.c        ****     for (count = 0; count < ITG3200_SIZE; count++){
 474               	.LM27:
 475 00b0 67E0      		ldi r22,lo8(7)
 476 00b2 80E0      		ldi r24,lo8(i2c_buf)
 477 00b4 90E0      		ldi r25,hi8(i2c_buf)
 478 00b6 0E94 0000 		call TWI_Get_Data_From_Transceiver
 479               	.L3:
 223:main.c        ****     }
 481               	.LM28:
 482 00ba 8E01      		movw r16,r28
 483 00bc 0F5F      		subi r16,-1
 484 00be 1F4F      		sbci r17,-1
 485 00c0 FE01      		movw r30,r28
 486 00c2 E050      		subi r30,lo8(-(i2c_buf-7))
 487 00c4 F040      		sbci r31,hi8(-(i2c_buf-7))
 488 00c6 8081      		ld r24,Z
 489 00c8 C050      		subi r28,lo8(-(tx_buf))
 490 00ca D040      		sbci r29,hi8(-(tx_buf))
 491 00cc 8883      		st Y,r24
 492 00ce E801      		movw r28,r16
 222:main.c        ****       tx_buf[i++] = i2c_buf[count+1];
 494               	.LM29:
 495 00d0 0E30      		cpi r16,14
 496 00d2 1105      		cpc r17,__zero_reg__
 497 00d4 01F4      		brne .L3
 226:main.c        ****     i2c_buf[1] = HMC5843_REGISTER_XMSB;
 499               	.LM30:
 500 00d6 8092 0000 		sts i2c_buf,r8
 227:main.c        ****     TWI_Start_Transceiver_With_Data(i2c_buf, 2);
 502               	.LM31:
 503 00da 7092 0000 		sts i2c_buf+1,r7
 228:main.c        **** 
 505               	.LM32:
 506 00de 62E0      		ldi r22,lo8(2)
 507 00e0 80E0      		ldi r24,lo8(i2c_buf)
 508 00e2 90E0      		ldi r25,hi8(i2c_buf)
 509 00e4 0E94 0000 		call TWI_Start_Transceiver_With_Data
 511               	.LM33:
 512 00e8 6092 0000 		sts i2c_buf,r6
 232:main.c        ****     TWI_Start_Transceiver_With_Data(i2c_buf, 7);
 514               	.LM34:
 515 00ec 67E0      		ldi r22,lo8(7)
 516 00ee 80E0      		ldi r24,lo8(i2c_buf)
 517 00f0 90E0      		ldi r25,hi8(i2c_buf)
 518 00f2 0E94 0000 		call TWI_Start_Transceiver_With_Data
 233:main.c        ****     TWI_Get_Data_From_Transceiver(i2c_buf,7);
 520               	.LM35:
 521 00f6 67E0      		ldi r22,lo8(7)
 522 00f8 80E0      		ldi r24,lo8(i2c_buf)
 523 00fa 90E0      		ldi r25,hi8(i2c_buf)
 524 00fc 0E94 0000 		call TWI_Get_Data_From_Transceiver
 525               	.L4:
 526 0100 F801      		movw r30,r16
 527 0102 E050      		subi r30,lo8(-(i2c_buf-13))
 528 0104 F040      		sbci r31,hi8(-(i2c_buf-13))
 234:main.c        ****     for (count = 0; count < HMC5843_SIZE; count++){
 235:main.c        ****       tx_buf[i++] = i2c_buf[count+1];
 530               	.LM36:
 531 0106 8081      		ld r24,Z
 532 0108 F801      		movw r30,r16
 533 010a E050      		subi r30,lo8(-(tx_buf))
 534 010c F040      		sbci r31,hi8(-(tx_buf))
 535 010e 8083      		st Z,r24
 536 0110 0F5F      		subi r16,-1
 537 0112 1F4F      		sbci r17,-1
 234:main.c        ****     for (count = 0; count < HMC5843_SIZE; count++){
 539               	.LM37:
 540 0114 0431      		cpi r16,20
 541 0116 1105      		cpc r17,__zero_reg__
 542 0118 01F4      		brne .L4
 236:main.c        ****     }
 237:main.c        ****     tx_len = i;
 544               	.LM38:
 545 011a 84E1      		ldi r24,lo8(20)
 546 011c 8093 0000 		sts tx_len,r24
 547 0120 E0E0      		ldi r30,lo8(tx_buf)
 548 0122 F0E0      		ldi r31,hi8(tx_buf)
 549 0124 A0E0      		ldi r26,lo8(pkt)
 550 0126 B0E0      		ldi r27,hi8(pkt)
 551               	.L5:
 552               	.LBB2:
 238:main.c        ****     packetReady = false;
 239:main.c        ****     //so we can resubmit while we build the new packet
 240:main.c        ****     for (int i = 0; i < tx_len; i++){
 554               	.LM39:
 555 0128 80E0      		ldi r24,hi8(tx_buf+20)
 556 012a E030      		cpi r30,lo8(tx_buf+20)
 557 012c F807      		cpc r31,r24
 558 012e 01F0      		breq .L12
 241:main.c        ****       pkt[i] = tx_buf[i];
 560               	.LM40:
 561 0130 8191      		ld r24,Z+
 562 0132 8D93      		st X+,r24
 563 0134 00C0      		rjmp .L5
 564               	.L12:
 565               	.LBE2:
 242:main.c        ****     }
 243:main.c        ****     packetReady = true;
 567               	.LM41:
 568 0136 81E0      		ldi r24,lo8(1)
 569 0138 8093 0000 		sts packetReady,r24
 244:main.c        ****     nrk_wait_until_next_period();
 571               	.LM42:
 572 013c 0E94 0000 		call nrk_wait_until_next_period
 245:main.c        ****   }
 574               	.LM43:
 575 0140 00C0      		rjmp .L7
 577               	.Lscope1:
 579               		.stabd	78,0,0
 580               		.section	.rodata.str1.1,"aMS",@progbits,1
 581               	.LC0:
 582 0000 5478 2054 		.string	"Tx Task PID=%u\r\n"
 582      6173 6B20 
 582      5049 443D 
 582      2575 0D0A 
 582      00
 583               		.text
 585               	.global	tx_task
 587               	tx_task:
 588               		.stabd	46,0,0
 246:main.c        **** }
 247:main.c        **** 
 248:main.c        **** 
 249:main.c        **** void tx_task ()
 250:main.c        **** {
 590               	.LM44:
 591               	.LFBB2:
 592 0142 CF93      		push r28
 593 0144 DF93      		push r29
 594 0146 CDB7      		in r28,__SP_L__
 595 0148 DEB7      		in r29,__SP_H__
 596 014a 2897      		sbiw r28,8
 597 014c 0FB6      		in __tmp_reg__,__SREG__
 598 014e F894      		cli
 599 0150 DEBF      		out __SP_H__,r29
 600 0152 0FBE      		out __SREG__,__tmp_reg__
 601 0154 CDBF      		out __SP_L__,r28
 602               	/* prologue: function */
 603               	/* frame size = 8 */
 604               	/* stack size = 10 */
 605               	.L__stack_usage = 10
 251:main.c        ****   int8_t v;
 252:main.c        ****   uint8_t cnt;
 253:main.c        ****   nrk_time_t t;
 254:main.c        **** 
 255:main.c        **** 
 256:main.c        ****   printf ("Tx Task PID=%u\r\n", nrk_get_pid ());
 607               	.LM45:
 608 0156 0E94 0000 		call nrk_get_pid
 609 015a 1F92      		push __zero_reg__
 610 015c 8F93      		push r24
 611 015e 80E0      		ldi r24,lo8(.LC0)
 612 0160 90E0      		ldi r25,hi8(.LC0)
 613 0162 9F93      		push r25
 614 0164 8F93      		push r24
 615 0166 0E94 0000 		call printf
 257:main.c        ****   t.secs = 5;
 617               	.LM46:
 618 016a 85E0      		ldi r24,lo8(5)
 619 016c 90E0      		ldi r25,0
 620 016e A0E0      		ldi r26,0
 621 0170 B0E0      		ldi r27,0
 622 0172 8983      		std Y+1,r24
 623 0174 9A83      		std Y+2,r25
 624 0176 AB83      		std Y+3,r26
 625 0178 BC83      		std Y+4,r27
 258:main.c        ****   t.nano_secs = 0;
 627               	.LM47:
 628 017a 1D82      		std Y+5,__zero_reg__
 629 017c 1E82      		std Y+6,__zero_reg__
 630 017e 1F82      		std Y+7,__zero_reg__
 631 0180 1886      		std Y+8,__zero_reg__
 259:main.c        **** 
 260:main.c        ****   // // setup a software watch dog timer
 261:main.c        ****   nrk_sw_wdt_init(0, &t, NULL);
 633               	.LM48:
 634 0182 40E0      		ldi r20,0
 635 0184 50E0      		ldi r21,0
 636 0186 BE01      		movw r22,r28
 637 0188 6F5F      		subi r22,-1
 638 018a 7F4F      		sbci r23,-1
 639 018c 80E0      		ldi r24,0
 640 018e 90E0      		ldi r25,0
 641 0190 0E94 0000 		call nrk_sw_wdt_init
 262:main.c        ****   nrk_sw_wdt_start(0);
 643               	.LM49:
 644 0194 80E0      		ldi r24,0
 645 0196 90E0      		ldi r25,0
 646 0198 0E94 0000 		call nrk_sw_wdt_start
 263:main.c        **** 
 264:main.c        **** 
 265:main.c        ****   while (!tdma_started())
 648               	.LM50:
 649 019c 0F90      		pop __tmp_reg__
 650 019e 0F90      		pop __tmp_reg__
 651 01a0 0F90      		pop __tmp_reg__
 652 01a2 0F90      		pop __tmp_reg__
 653               	.L14:
 654 01a4 0E94 0000 		call tdma_started
 655 01a8 8111      		cpse r24,__zero_reg__
 656 01aa 00C0      		rjmp .L16
 266:main.c        ****     nrk_wait_until_next_period ();
 658               	.LM51:
 659 01ac 0E94 0000 		call nrk_wait_until_next_period
 660 01b0 00C0      		rjmp .L14
 661               	.L20:
 662               	.LBB3:
 267:main.c        **** 
 268:main.c        ****   cnt = 0;
 269:main.c        **** 
 270:main.c        ****   while (1) {
 271:main.c        ****     // Update watchdog timer
 272:main.c        ****     nrk_sw_wdt_update(0);
 273:main.c        ****     nrk_led_set(RED_LED);
 274:main.c        **** 
 275:main.c        ****     // if sensor data hasn't been gathered yet
 276:main.c        ****     if (!packetReady){
 277:main.c        ****        continue;
 278:main.c        ****     }
 279:main.c        ****     nrk_led_clr(RED_LED);
 664               	.LM52:
 665 01b2 80E0      		ldi r24,0
 666 01b4 90E0      		ldi r25,0
 667 01b6 0E94 0000 		call nrk_led_clr
 280:main.c        ****     v = tdma_send (&tx_tdma_fd, &pkt, tx_len, TDMA_BLOCKING);
 669               	.LM53:
 670 01ba 20E0      		ldi r18,0
 671 01bc 4091 0000 		lds r20,tx_len
 672 01c0 60E0      		ldi r22,lo8(pkt)
 673 01c2 70E0      		ldi r23,hi8(pkt)
 674 01c4 80E0      		ldi r24,lo8(tx_tdma_fd)
 675 01c6 90E0      		ldi r25,hi8(tx_tdma_fd)
 676 01c8 0E94 0000 		call tdma_send
 677               	.L16:
 272:main.c        ****     nrk_led_set(RED_LED);
 679               	.LM54:
 680 01cc 80E0      		ldi r24,0
 681 01ce 90E0      		ldi r25,0
 682 01d0 0E94 0000 		call nrk_sw_wdt_update
 273:main.c        **** 
 684               	.LM55:
 685 01d4 80E0      		ldi r24,0
 686 01d6 90E0      		ldi r25,0
 687 01d8 0E94 0000 		call nrk_led_set
 276:main.c        ****        continue;
 689               	.LM56:
 690 01dc 8091 0000 		lds r24,packetReady
 691 01e0 8823      		tst r24
 692 01e2 01F0      		breq .L16
 693 01e4 00C0      		rjmp .L20
 694               	.LBE3:
 699               	.Lscope2:
 701               		.stabd	78,0,0
 703               	.global	init_itg3200
 705               	init_itg3200:
 706               		.stabd	46,0,0
 145:main.c        ****     /* put in standby mode while we change fifo control bits */
 708               	.LM57:
 709               	.LFBB3:
 710               	/* prologue: function */
 711               	/* frame size = 0 */
 712               	/* stack size = 0 */
 713               	.L__stack_usage = 0
 147:main.c        ****   i2c_buf[1] = ITG3200_REGISTER_DLPF;
 715               	.LM58:
 716 01e6 E0E0      		ldi r30,lo8(i2c_buf)
 717 01e8 F0E0      		ldi r31,hi8(i2c_buf)
 718 01ea 80ED      		ldi r24,lo8(-48)
 719 01ec 8083      		st Z,r24
 148:main.c        ****   i2c_buf[2] = ITG3200_FULLSCALE | ITG3200_42HZ;
 721               	.LM59:
 722 01ee 86E1      		ldi r24,lo8(22)
 723 01f0 8183      		std Z+1,r24
 149:main.c        ****   TWI_Start_Transceiver_With_Data(i2c_buf, 3);
 725               	.LM60:
 726 01f2 8BE1      		ldi r24,lo8(27)
 727 01f4 8283      		std Z+2,r24
 150:main.c        **** }
 729               	.LM61:
 730 01f6 63E0      		ldi r22,lo8(3)
 731 01f8 CF01      		movw r24,r30
 732 01fa 0C94 0000 		jmp TWI_Start_Transceiver_With_Data
 734               	.Lscope3:
 736               		.stabd	78,0,0
 738               	.global	init_hmc5843
 740               	init_hmc5843:
 741               		.stabd	46,0,0
 153:main.c        ****     /* put in standby mode while we change fifo control bits */
 743               	.LM62:
 744               	.LFBB4:
 745               	/* prologue: function */
 746               	/* frame size = 0 */
 747               	/* stack size = 0 */
 748               	.L__stack_usage = 0
 155:main.c        ****   i2c_buf[1] = HMC5843_REGISTER_MEASMODE;
 750               	.LM63:
 751 01fe E0E0      		ldi r30,lo8(i2c_buf)
 752 0200 F0E0      		ldi r31,hi8(i2c_buf)
 753 0202 8CE3      		ldi r24,lo8(60)
 754 0204 8083      		st Z,r24
 156:main.c        ****   i2c_buf[2] = HMC5843_MEASMODE_CONT;
 756               	.LM64:
 757 0206 82E0      		ldi r24,lo8(2)
 758 0208 8183      		std Z+1,r24
 157:main.c        ****   TWI_Start_Transceiver_With_Data(i2c_buf, 3);
 760               	.LM65:
 761 020a 1282      		std Z+2,__zero_reg__
 158:main.c        **** }
 763               	.LM66:
 764 020c 63E0      		ldi r22,lo8(3)
 765 020e CF01      		movw r24,r30
 766 0210 0C94 0000 		jmp TWI_Start_Transceiver_With_Data
 768               	.Lscope4:
 770               		.stabd	78,0,0
 772               	.global	init_adxl345
 774               	init_adxl345:
 775               		.stabd	46,0,0
 162:main.c        ****   unsigned int read = 0;
 777               	.LM67:
 778               	.LFBB5:
 779 0214 0F93      		push r16
 780 0216 1F93      		push r17
 781 0218 CF93      		push r28
 782 021a DF93      		push r29
 783               	/* prologue: function */
 784               	/* frame size = 0 */
 785               	/* stack size = 4 */
 786               	.L__stack_usage = 4
 166:main.c        ****   i2c_buf[1] = ADXL_REGISTER_PWRCTL;
 788               	.LM68:
 789 021c C0E0      		ldi r28,lo8(i2c_buf)
 790 021e D0E0      		ldi r29,hi8(i2c_buf)
 791 0220 16EA      		ldi r17,lo8(-90)
 792 0222 1883      		st Y,r17
 167:main.c        ****   i2c_buf[2] = ADXL_PWRCTL_STBY;
 794               	.LM69:
 795 0224 0DE2      		ldi r16,lo8(45)
 796 0226 0983      		std Y+1,r16
 168:main.c        ****   TWI_Start_Transceiver_With_Data(i2c_buf, 3);
 798               	.LM70:
 799 0228 1A82      		std Y+2,__zero_reg__
 169:main.c        **** 
 801               	.LM71:
 802 022a 63E0      		ldi r22,lo8(3)
 803 022c CE01      		movw r24,r28
 804 022e 0E94 0000 		call TWI_Start_Transceiver_With_Data
 172:main.c        ****   i2c_buf[1] = ADXL_REGISTER_FIFOCTL;
 806               	.LM72:
 807 0232 1883      		st Y,r17
 173:main.c        ****   i2c_buf[2] = ADXL_FIFOCTL_STREAM;
 809               	.LM73:
 810 0234 88E3      		ldi r24,lo8(56)
 811 0236 8983      		std Y+1,r24
 174:main.c        ****   TWI_Start_Transceiver_With_Data(i2c_buf,3);
 813               	.LM74:
 814 0238 80E8      		ldi r24,lo8(-128)
 815 023a 8A83      		std Y+2,r24
 175:main.c        **** 
 817               	.LM75:
 818 023c 63E0      		ldi r22,lo8(3)
 819 023e CE01      		movw r24,r28
 820 0240 0E94 0000 		call TWI_Start_Transceiver_With_Data
 178:main.c        ****   i2c_buf[1] = ADXL_REGISTER_DTFMT;
 822               	.LM76:
 823 0244 1883      		st Y,r17
 179:main.c        ****   i2c_buf[2] = ADXL_16G_DTFMT;
 825               	.LM77:
 826 0246 81E3      		ldi r24,lo8(49)
 827 0248 8983      		std Y+1,r24
 180:main.c        ****   TWI_Start_Transceiver_With_Data(i2c_buf,3);
 829               	.LM78:
 830 024a 8FE0      		ldi r24,lo8(15)
 831 024c 8A83      		std Y+2,r24
 181:main.c        **** 
 833               	.LM79:
 834 024e 63E0      		ldi r22,lo8(3)
 835 0250 CE01      		movw r24,r28
 836 0252 0E94 0000 		call TWI_Start_Transceiver_With_Data
 184:main.c        ****   i2c_buf[1] = ADXL_REGISTER_PWRCTL;
 838               	.LM80:
 839 0256 1883      		st Y,r17
 185:main.c        ****   i2c_buf[2] = ADXL_PWRCTL_MEASURE;
 841               	.LM81:
 842 0258 0983      		std Y+1,r16
 186:main.c        ****   TWI_Start_Transceiver_With_Data(i2c_buf, 3);
 844               	.LM82:
 845 025a 88E0      		ldi r24,lo8(8)
 846 025c 8A83      		std Y+2,r24
 187:main.c        **** }
 848               	.LM83:
 849 025e 63E0      		ldi r22,lo8(3)
 850 0260 CE01      		movw r24,r28
 851               	/* epilogue start */
 188:main.c        **** 
 853               	.LM84:
 854 0262 DF91      		pop r29
 855 0264 CF91      		pop r28
 856 0266 1F91      		pop r17
 857 0268 0F91      		pop r16
 187:main.c        **** }
 859               	.LM85:
 860 026a 0C94 0000 		jmp TWI_Start_Transceiver_With_Data
 862               	.Lscope5:
 864               		.stabd	78,0,0
 866               	.global	nrk_create_taskset
 868               	nrk_create_taskset:
 869               		.stabd	46,0,0
 281:main.c        ****     }
 282:main.c        **** }
 283:main.c        **** 
 284:main.c        **** 
 285:main.c        **** 
 286:main.c        **** void
 287:main.c        **** nrk_create_taskset()
 288:main.c        **** {
 871               	.LM86:
 872               	.LFBB6:
 873 026e CF92      		push r12
 874 0270 DF92      		push r13
 875 0272 EF92      		push r14
 876 0274 FF92      		push r15
 877 0276 CF93      		push r28
 878               	/* prologue: function */
 879               	/* frame size = 0 */
 880               	/* stack size = 5 */
 881               	.L__stack_usage = 5
 289:main.c        ****   nrk_task_set_entry_function( &TaskOne, task_imu);
 883               	.LM87:
 884 0278 60E0      		ldi r22,lo8(gs(task_imu))
 885 027a 70E0      		ldi r23,hi8(gs(task_imu))
 886 027c 80E0      		ldi r24,lo8(TaskOne)
 887 027e 90E0      		ldi r25,hi8(TaskOne)
 888 0280 0E94 0000 		call nrk_task_set_entry_function
 290:main.c        ****   nrk_task_set_stk( &TaskOne, Stack1, NRK_APP_STACKSIZE);
 890               	.LM88:
 891 0284 40E8      		ldi r20,lo8(-128)
 892 0286 50E0      		ldi r21,0
 893 0288 60E0      		ldi r22,lo8(Stack1)
 894 028a 70E0      		ldi r23,hi8(Stack1)
 895 028c 80E0      		ldi r24,lo8(TaskOne)
 896 028e 90E0      		ldi r25,hi8(TaskOne)
 897 0290 0E94 0000 		call nrk_task_set_stk
 291:main.c        ****   TaskOne.prio = 1;
 899               	.LM89:
 900 0294 E0E0      		ldi r30,lo8(TaskOne)
 901 0296 F0E0      		ldi r31,hi8(TaskOne)
 902 0298 C1E0      		ldi r28,lo8(1)
 903 029a C087      		std Z+8,r28
 292:main.c        ****   TaskOne.FirstActivation = TRUE;
 905               	.LM90:
 906 029c C783      		std Z+7,r28
 293:main.c        ****   TaskOne.Type = BASIC_TASK;
 908               	.LM91:
 909 029e C187      		std Z+9,r28
 294:main.c        ****   TaskOne.SchType = PREEMPTIVE;
 911               	.LM92:
 912 02a0 C287      		std Z+10,r28
 295:main.c        ****   TaskOne.period.secs = 0;
 914               	.LM93:
 915 02a2 1386      		std Z+11,__zero_reg__
 916 02a4 1486      		std Z+12,__zero_reg__
 917 02a6 1586      		std Z+13,__zero_reg__
 918 02a8 1686      		std Z+14,__zero_reg__
 296:main.c        ****   TaskOne.period.nano_secs = 25 * NANOS_PER_MS;
 920               	.LM94:
 921 02aa 80E4      		ldi r24,lo8(64)
 922 02ac 98E7      		ldi r25,lo8(120)
 923 02ae ADE7      		ldi r26,lo8(125)
 924 02b0 B1E0      		ldi r27,lo8(1)
 925 02b2 8787      		std Z+15,r24
 926 02b4 908B      		std Z+16,r25
 927 02b6 A18B      		std Z+17,r26
 928 02b8 B28B      		std Z+18,r27
 297:main.c        ****   TaskOne.cpu_reserve.secs = 0;
 930               	.LM95:
 931 02ba 138A      		std Z+19,__zero_reg__
 932 02bc 148A      		std Z+20,__zero_reg__
 933 02be 158A      		std Z+21,__zero_reg__
 934 02c0 168A      		std Z+22,__zero_reg__
 298:main.c        ****   TaskOne.cpu_reserve.nano_secs = 0;
 936               	.LM96:
 937 02c2 178A      		std Z+23,__zero_reg__
 938 02c4 108E      		std Z+24,__zero_reg__
 939 02c6 118E      		std Z+25,__zero_reg__
 940 02c8 128E      		std Z+26,__zero_reg__
 299:main.c        ****   TaskOne.offset.secs = 1;
 942               	.LM97:
 943 02ca C12C      		mov r12,__zero_reg__
 944 02cc D12C      		mov r13,__zero_reg__
 945 02ce 7601      		movw r14,r12
 946 02d0 C394      		inc r12
 947 02d2 C38E      		std Z+27,r12
 948 02d4 D48E      		std Z+28,r13
 949 02d6 E58E      		std Z+29,r14
 950 02d8 F68E      		std Z+30,r15
 300:main.c        ****   TaskOne.offset.nano_secs= 0;
 952               	.LM98:
 953 02da 178E      		std Z+31,__zero_reg__
 954 02dc 10A2      		std Z+32,__zero_reg__
 955 02de 11A2      		std Z+33,__zero_reg__
 956 02e0 12A2      		std Z+34,__zero_reg__
 301:main.c        ****   nrk_activate_task (&TaskOne);
 958               	.LM99:
 959 02e2 CF01      		movw r24,r30
 960 02e4 0E94 0000 		call nrk_activate_task
 302:main.c        **** 
 303:main.c        ****   nrk_task_set_entry_function (&tx_task_info, tx_task);
 962               	.LM100:
 963 02e8 60E0      		ldi r22,lo8(gs(tx_task))
 964 02ea 70E0      		ldi r23,hi8(gs(tx_task))
 965 02ec 80E0      		ldi r24,lo8(tx_task_info)
 966 02ee 90E0      		ldi r25,hi8(tx_task_info)
 967 02f0 0E94 0000 		call nrk_task_set_entry_function
 304:main.c        ****   nrk_task_set_stk (&tx_task_info, tx_task_stack, NRK_APP_STACKSIZE);
 969               	.LM101:
 970 02f4 40E8      		ldi r20,lo8(-128)
 971 02f6 50E0      		ldi r21,0
 972 02f8 60E0      		ldi r22,lo8(tx_task_stack)
 973 02fa 70E0      		ldi r23,hi8(tx_task_stack)
 974 02fc 80E0      		ldi r24,lo8(tx_task_info)
 975 02fe 90E0      		ldi r25,hi8(tx_task_info)
 976 0300 0E94 0000 		call nrk_task_set_stk
 305:main.c        ****   tx_task_info.prio = 1;
 978               	.LM102:
 979 0304 E0E0      		ldi r30,lo8(tx_task_info)
 980 0306 F0E0      		ldi r31,hi8(tx_task_info)
 981 0308 C087      		std Z+8,r28
 306:main.c        ****   tx_task_info.FirstActivation = TRUE;
 983               	.LM103:
 984 030a C783      		std Z+7,r28
 307:main.c        ****   tx_task_info.Type = BASIC_TASK;
 986               	.LM104:
 987 030c C187      		std Z+9,r28
 308:main.c        ****   tx_task_info.SchType = PREEMPTIVE;
 989               	.LM105:
 990 030e C287      		std Z+10,r28
 309:main.c        ****   tx_task_info.period.secs = 0;
 992               	.LM106:
 993 0310 1386      		std Z+11,__zero_reg__
 994 0312 1486      		std Z+12,__zero_reg__
 995 0314 1586      		std Z+13,__zero_reg__
 996 0316 1686      		std Z+14,__zero_reg__
 310:main.c        ****   tx_task_info.period.nano_secs = 5 * NANOS_PER_MS;
 998               	.LM107:
 999 0318 80E4      		ldi r24,lo8(64)
 1000 031a 9BE4      		ldi r25,lo8(75)
 1001 031c ACE4      		ldi r26,lo8(76)
 1002 031e B0E0      		ldi r27,0
 1003 0320 8787      		std Z+15,r24
 1004 0322 908B      		std Z+16,r25
 1005 0324 A18B      		std Z+17,r26
 1006 0326 B28B      		std Z+18,r27
 311:main.c        ****   tx_task_info.cpu_reserve.secs = 0;
 1008               	.LM108:
 1009 0328 138A      		std Z+19,__zero_reg__
 1010 032a 148A      		std Z+20,__zero_reg__
 1011 032c 158A      		std Z+21,__zero_reg__
 1012 032e 168A      		std Z+22,__zero_reg__
 312:main.c        ****   tx_task_info.cpu_reserve.nano_secs = 0 * NANOS_PER_MS;
 1014               	.LM109:
 1015 0330 178A      		std Z+23,__zero_reg__
 1016 0332 108E      		std Z+24,__zero_reg__
 1017 0334 118E      		std Z+25,__zero_reg__
 1018 0336 128E      		std Z+26,__zero_reg__
 313:main.c        ****   tx_task_info.offset.secs = 1;
 1020               	.LM110:
 1021 0338 C38E      		std Z+27,r12
 1022 033a D48E      		std Z+28,r13
 1023 033c E58E      		std Z+29,r14
 1024 033e F68E      		std Z+30,r15
 314:main.c        ****   tx_task_info.offset.nano_secs = 0;
 1026               	.LM111:
 1027 0340 178E      		std Z+31,__zero_reg__
 1028 0342 10A2      		std Z+32,__zero_reg__
 1029 0344 11A2      		std Z+33,__zero_reg__
 1030 0346 12A2      		std Z+34,__zero_reg__
 315:main.c        ****   nrk_activate_task (&tx_task_info);
 1032               	.LM112:
 1033 0348 CF01      		movw r24,r30
 1034 034a 0E94 0000 		call nrk_activate_task
 1035               	/* epilogue start */
 316:main.c        **** 
 317:main.c        ****   tdma_task_config ();
 318:main.c        **** }
 1037               	.LM113:
 1038 034e CF91      		pop r28
 1039 0350 FF90      		pop r15
 1040 0352 EF90      		pop r14
 1041 0354 DF90      		pop r13
 1042 0356 CF90      		pop r12
 317:main.c        **** }
 1044               	.LM114:
 1045 0358 0C94 0000 		jmp tdma_task_config
 1047               	.Lscope6:
 1049               		.stabd	78,0,0
 1050               		.section	.rodata.str1.1
 1051               	.LC1:
 1052 0011 6D61 6320 		.string	"mac = %d\r\n"
 1052      3D20 2564 
 1052      0D0A 00
 1053               		.section	.text.startup,"ax",@progbits
 1055               	.global	main
 1057               	main:
 1058               		.stabd	46,0,0
 106:main.c        **** 
 1060               	.LM115:
 1061               	.LFBB7:
 1062               	/* prologue: function */
 1063               	/* frame size = 0 */
 1064               	/* stack size = 0 */
 1065               	.L__stack_usage = 0
 108:main.c        ****   nrk_setup_uart(UART_BAUDRATE_115K2);
 1067               	.LM116:
 1068 0000 0E94 0000 		call nrk_setup_ports
 109:main.c        ****   nrk_init();
 1070               	.LM117:
 1071 0004 80E1      		ldi r24,lo8(16)
 1072 0006 90E0      		ldi r25,0
 1073 0008 0E94 0000 		call nrk_setup_uart
 110:main.c        **** 
 1075               	.LM118:
 1076 000c 0E94 0000 		call nrk_init
 112:main.c        ****   sei();
 1078               	.LM119:
 1079 0010 0E94 0000 		call TWI_Master_Initialise
 113:main.c        ****   init_adxl345();
 1081               	.LM120:
 1082               	/* #APP */
 1083               	 ;  113 "main.c" 1
 1084 0014 7894      		sei
 1085               	 ;  0 "" 2
 114:main.c        ****   init_itg3200();
 1087               	.LM121:
 1088               	/* #NOAPP */
 1089 0016 0E94 0000 		call init_adxl345
 115:main.c        ****   init_hmc5843();
 1091               	.LM122:
 1092 001a 0E94 0000 		call init_itg3200
 116:main.c        ****   /* initialize sequence number, used to sync with master */
 1094               	.LM123:
 1095 001e 0E94 0000 		call init_hmc5843
 118:main.c        **** 
 1097               	.LM124:
 1098 0022 1092 0000 		sts sequenceNo+1,__zero_reg__
 1099 0026 1092 0000 		sts sequenceNo,__zero_reg__
 121:main.c        ****   
 1101               	.LM125:
 1102 002a 1092 0000 		sts packetReady,__zero_reg__
 124:main.c        ****   printf("mac = %d\r\n",mac_address);
 1104               	.LM126:
 1105 002e 82E0      		ldi r24,lo8(2)
 1106 0030 90E0      		ldi r25,0
 1107 0032 9093 0000 		sts mac_address+1,r25
 1108 0036 8093 0000 		sts mac_address,r24
 125:main.c        ****   tdma_init (TDMA_CLIENT, DEFAULT_CHANNEL, CLIENT_MAC);
 1110               	.LM127:
 1111 003a 1F92      		push __zero_reg__
 1112 003c 8F93      		push r24
 1113 003e 80E0      		ldi r24,lo8(.LC1)
 1114 0040 90E0      		ldi r25,hi8(.LC1)
 1115 0042 9F93      		push r25
 1116 0044 8F93      		push r24
 1117 0046 0E94 0000 		call printf
 126:main.c        **** 
 1119               	.LM128:
 1120 004a 42E0      		ldi r20,lo8(2)
 1121 004c 50E0      		ldi r21,0
 1122 004e 6DE0      		ldi r22,lo8(13)
 1123 0050 82E0      		ldi r24,lo8(2)
 1124 0052 0E94 0000 		call tdma_init
 131:main.c        **** 
 1126               	.LM129:
 1127 0056 8091 0000 		lds r24,mac_address
 1128 005a 9091 0000 		lds r25,mac_address+1
 1129 005e 0E94 0000 		call tdma_tx_slot_add
 133:main.c        ****   nrk_led_clr(BLUE_LED);
 1131               	.LM130:
 1132 0062 82E0      		ldi r24,lo8(2)
 1133 0064 90E0      		ldi r25,0
 1134 0066 0E94 0000 		call nrk_led_clr
 134:main.c        ****   nrk_led_clr(GREEN_LED);
 1136               	.LM131:
 1137 006a 83E0      		ldi r24,lo8(3)
 1138 006c 90E0      		ldi r25,0
 1139 006e 0E94 0000 		call nrk_led_clr
 135:main.c        ****   nrk_led_clr(RED_LED);
 1141               	.LM132:
 1142 0072 81E0      		ldi r24,lo8(1)
 1143 0074 90E0      		ldi r25,0
 1144 0076 0E94 0000 		call nrk_led_clr
 136:main.c        ****  
 1146               	.LM133:
 1147 007a 80E0      		ldi r24,0
 1148 007c 90E0      		ldi r25,0
 1149 007e 0E94 0000 		call nrk_led_clr
 138:main.c        ****   nrk_create_taskset();
 1151               	.LM134:
 1152 0082 20E0      		ldi r18,0
 1153 0084 30E0      		ldi r19,0
 1154 0086 A901      		movw r20,r18
 1155 0088 60E0      		ldi r22,0
 1156 008a 70E0      		ldi r23,0
 1157 008c CB01      		movw r24,r22
 1158 008e 0E94 0000 		call nrk_time_set
 139:main.c        ****   nrk_start();
 1160               	.LM135:
 1161 0092 0E94 0000 		call nrk_create_taskset
 140:main.c        ****   
 1163               	.LM136:
 1164 0096 0E94 0000 		call nrk_start
 1165 009a 0F90      		pop __tmp_reg__
 1166 009c 0F90      		pop __tmp_reg__
 1167 009e 0F90      		pop __tmp_reg__
 1168 00a0 0F90      		pop __tmp_reg__
 143:main.c        **** 
 1170               	.LM137:
 1171 00a2 80E0      		ldi r24,0
 1172 00a4 90E0      		ldi r25,0
 1173 00a6 0895      		ret
 1175               	.Lscope7:
 1177               		.stabd	78,0,0
 1178               		.comm	tx_task_info,35,1
 1179               		.comm	tx_task_stack,128,1
 1180               		.comm	rx_task_info,35,1
 1181               		.comm	rx_task_stack,128,1
 1182               		.comm	TaskOne,35,1
 1183               		.comm	Stack1,128,1
 1184               	.global	aes_key
 1185               		.data
 1188               	aes_key:
 1189 0000 00        		.byte	0
 1190 0001 11        		.byte	17
 1191 0002 22        		.byte	34
 1192 0003 33        		.byte	51
 1193 0004 44        		.byte	68
 1194 0005 55        		.byte	85
 1195 0006 66        		.byte	102
 1196 0007 77        		.byte	119
 1197 0008 88        		.byte	-120
 1198 0009 99        		.byte	-103
 1199 000a AA        		.byte	-86
 1200 000b BB        		.byte	-69
 1201 000c CC        		.byte	-52
 1202 000d DD        		.byte	-35
 1203 000e EE        		.byte	-18
 1204 000f FF        		.byte	-1
 1205               		.comm	mac_address,2,1
 1206               		.comm	packetReady,1,1
 1207               		.comm	sequenceNo,2,1
 1208               		.comm	tx_len,1,1
 1209               		.comm	pkt,112,1
 1210               		.comm	tx_buf,112,1
 1211               		.comm	i2c_buf,16,1
 1212               		.comm	rx_tdma_fd,18,1
 1213               		.comm	tx_tdma_fd,18,1
 1214               		.comm	tdma_rfTxInfo,7,1
 1215               		.comm	tdma_rfRxInfo,12,1
 1216               		.comm	tdma_enable_signal,1,1
 1217               		.comm	tdma_tx_pkt_done_signal,1,1
 1218               		.comm	tdma_rx_pkt_signal,1,1
 1219               		.comm	_nrk_stats_sleep_time,8,1
 1220               		.comm	cur_task_stats,120,1
 1221               		.comm	app_timer0_prescale,1,1
 1222               		.comm	app_timer0_callback,2,1
 1223               		.comm	_nrk_time_trigger,1,1
 1224               		.comm	_nrk_prev_timer_val,1,1
 1225               		.comm	error_num,1,1
 1226               		.comm	error_task,1,1
 1227               		.comm	nrk_kernel_stk_ptr,2,1
 1228               		.comm	nrk_idle_task_stk,128,1
 1229               		.comm	_nrk_signal_list,4,1
 1262               		.text
 1264               	.Letext0:
 1265               		.ident	"GCC: (GNU) 4.9.1"
 1266               	.global __do_copy_data
 1267               	.global __do_clear_bss
DEFINED SYMBOLS
                            *ABS*:0000000000000000 main.c
/var/folders/5w/cgn1dq610yqf6q25zlv0gqm40000gn/T//ccvXEhB3.s:2      *ABS*:000000000000003e __SP_H__
/var/folders/5w/cgn1dq610yqf6q25zlv0gqm40000gn/T//ccvXEhB3.s:3      *ABS*:000000000000003d __SP_L__
/var/folders/5w/cgn1dq610yqf6q25zlv0gqm40000gn/T//ccvXEhB3.s:4      *ABS*:000000000000003f __SREG__
/var/folders/5w/cgn1dq610yqf6q25zlv0gqm40000gn/T//ccvXEhB3.s:5      *ABS*:000000000000003b __RAMPZ__
/var/folders/5w/cgn1dq610yqf6q25zlv0gqm40000gn/T//ccvXEhB3.s:6      *ABS*:0000000000000000 __tmp_reg__
/var/folders/5w/cgn1dq610yqf6q25zlv0gqm40000gn/T//ccvXEhB3.s:7      *ABS*:0000000000000001 __zero_reg__
/var/folders/5w/cgn1dq610yqf6q25zlv0gqm40000gn/T//ccvXEhB3.s:339    .text:0000000000000000 task_imu
                            *COM*:0000000000000070 tx_buf
                            *COM*:0000000000000002 sequenceNo
                            *COM*:0000000000000010 i2c_buf
                            *COM*:0000000000000001 tx_len
                            *COM*:0000000000000070 pkt
                            *COM*:0000000000000001 packetReady
/var/folders/5w/cgn1dq610yqf6q25zlv0gqm40000gn/T//ccvXEhB3.s:587    .text:0000000000000142 tx_task
                            *COM*:0000000000000012 tx_tdma_fd
/var/folders/5w/cgn1dq610yqf6q25zlv0gqm40000gn/T//ccvXEhB3.s:705    .text:00000000000001e6 init_itg3200
/var/folders/5w/cgn1dq610yqf6q25zlv0gqm40000gn/T//ccvXEhB3.s:740    .text:00000000000001fe init_hmc5843
/var/folders/5w/cgn1dq610yqf6q25zlv0gqm40000gn/T//ccvXEhB3.s:774    .text:0000000000000214 init_adxl345
/var/folders/5w/cgn1dq610yqf6q25zlv0gqm40000gn/T//ccvXEhB3.s:868    .text:000000000000026e nrk_create_taskset
                            *COM*:0000000000000023 TaskOne
                            *COM*:0000000000000080 Stack1
                            *COM*:0000000000000023 tx_task_info
                            *COM*:0000000000000080 tx_task_stack
/var/folders/5w/cgn1dq610yqf6q25zlv0gqm40000gn/T//ccvXEhB3.s:1057   .text.startup:0000000000000000 main
                            *COM*:0000000000000002 mac_address
                            *COM*:0000000000000023 rx_task_info
                            *COM*:0000000000000080 rx_task_stack
/var/folders/5w/cgn1dq610yqf6q25zlv0gqm40000gn/T//ccvXEhB3.s:1188   .data:0000000000000000 aes_key
                            *COM*:0000000000000012 rx_tdma_fd
                            *COM*:0000000000000007 tdma_rfTxInfo
                            *COM*:000000000000000c tdma_rfRxInfo
                            *COM*:0000000000000001 tdma_enable_signal
                            *COM*:0000000000000001 tdma_tx_pkt_done_signal
                            *COM*:0000000000000001 tdma_rx_pkt_signal
                            *COM*:0000000000000008 _nrk_stats_sleep_time
                            *COM*:0000000000000078 cur_task_stats
                            *COM*:0000000000000001 app_timer0_prescale
                            *COM*:0000000000000002 app_timer0_callback
                            *COM*:0000000000000001 _nrk_time_trigger
                            *COM*:0000000000000001 _nrk_prev_timer_val
                            *COM*:0000000000000001 error_num
                            *COM*:0000000000000001 error_task
                            *COM*:0000000000000002 nrk_kernel_stk_ptr
                            *COM*:0000000000000080 nrk_idle_task_stk
                            *COM*:0000000000000004 _nrk_signal_list

UNDEFINED SYMBOLS
TWI_Start_Transceiver_With_Data
TWI_Get_Data_From_Transceiver
nrk_wait_until_next_period
nrk_get_pid
printf
nrk_sw_wdt_init
nrk_sw_wdt_start
tdma_started
nrk_led_clr
tdma_send
nrk_sw_wdt_update
nrk_led_set
nrk_task_set_entry_function
nrk_task_set_stk
nrk_activate_task
tdma_task_config
nrk_setup_ports
nrk_setup_uart
nrk_init
TWI_Master_Initialise
tdma_init
tdma_tx_slot_add
nrk_time_set
nrk_start
__do_copy_data
__do_clear_bss
