   1               		.file	"main.c"
   2               	__SP_H__ = 0x3e
   3               	__SP_L__ = 0x3d
   4               	__SREG__ = 0x3f
   5               	__RAMPZ__ = 0x3b
   6               	__tmp_reg__ = 0
   7               	__zero_reg__ = 1
  10               		.text
  11               	.Ltext0:
 336               		.section	.rodata.str1.1,"aMS",@progbits,1
 337               	.LC0:
 338 0000 5478 2054 		.string	"Tx Task PID=%u\r\n"
 338      6173 6B20 
 338      5049 443D 
 338      2575 0D0A 
 338      00
 339               	.LC1:
 340 0011 4865 7920 		.string	"Hey guys\r\n"
 340      6775 7973 
 340      0D0A 00
 341               	.LC2:
 342 001c 7061 636B 		.string	"packet receiving error!\r"
 342      6574 2072 
 342      6563 6569 
 342      7669 6E67 
 342      2065 7272 
 343               		.text
 345               	.global	tx_task
 347               	tx_task:
 348               		.stabd	46,0,0
   1:main.c        **** /******************************************************************************
   2:main.c        **** *  Nano-RK, a real-time operating system for sensor networks.
   3:main.c        **** *  Copyright (C) 2007, Real-Time and Multimedia Lab, Carnegie Mellon University
   4:main.c        **** *  All rights reserved.
   5:main.c        **** *
   6:main.c        **** *  This is the Open Source Version of Nano-RK included as part of a Dual
   7:main.c        **** *  Licensing Model. If you are unsure which license to use please refer to:
   8:main.c        **** *  http://www.nanork.org/nano-RK/wiki/Licensing
   9:main.c        **** *
  10:main.c        **** *  This program is free software: you can redistribute it and/or modify
  11:main.c        **** *  it under the terms of the GNU General Public License as published by
  12:main.c        **** *  the Free Software Foundation, version 2.0 of the License.
  13:main.c        **** *
  14:main.c        **** *  This program is distributed in the hope that it will be useful,
  15:main.c        **** *  but WITHOUT ANY WARRANTY; without even the implied warranty of
  16:main.c        **** *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  17:main.c        **** *  GNU General Public License for more details.
  18:main.c        **** *
  19:main.c        **** *  You should have received a copy of the GNU General Public License
  20:main.c        **** *  along with this program.  If not, see <http://www.gnu.org/licenses/>.
  21:main.c        **** *
  22:main.c        **** *******************************************************************************/
  23:main.c        **** 
  24:main.c        **** #include <nrk.h>
  25:main.c        **** #include <include.h>
  26:main.c        **** #include <ulib.h>
  27:main.c        **** #include <stdio.h>
  28:main.c        **** #include <hal.h>
  29:main.c        **** #include <nrk_error.h>
  30:main.c        **** #include <nrk_timer.h>
  31:main.c        **** #include <nrk_stack_check.h>
  32:main.c        **** #include <nrk_stats.h>
  33:main.c        **** #include <pcf_tdma.h>
  34:main.c        **** #include <TWI_Master.h>
  35:main.c        **** #include <tdma_cons.h>
  36:main.c        **** 
  37:main.c        **** // Constants for the accelrometer
  38:main.c        **** //There are 6 data registers, they are sequential starting 
  39:main.c        **** //with the LSB of X.  We'll read all 6 in a burst and won't
  40:main.c        **** //address them individually
  41:main.c        **** #define ADXL345_REGISTER_XLSB 0x32
  42:main.c        **** 
  43:main.c        **** //Need to set power control bit to wake up the adxl345
  44:main.c        **** #define ADXL_REGISTER_PWRCTL 0x2D
  45:main.c        **** #define ADXL_REGISTER_FIFOCTL 0x38
  46:main.c        **** #define ADXL_FIFOCTL_STREAM 1<<7
  47:main.c        **** #define ADXL_PWRCTL_MEASURE 1 << 3
  48:main.c        **** #define ADXL_PWRCTL_STBY 0
  49:main.c        **** #define ADXL345_ADDRESS 0xA6
  50:main.c        **** #define ADXL_SIZE 6
  51:main.c        **** 
  52:main.c        **** 
  53:main.c        **** //Constants for the gyroscope
  54:main.c        **** #define ITG3200_ADDRESS 0xD0
  55:main.c        **** //request burst of 6 bytes from this address
  56:main.c        **** #define ITG3200_REGISTER_XMSB 0x1D
  57:main.c        **** #define ITG3200_REGISTER_DLPF 0x16
  58:main.c        **** #define ITG3200_FULLSCALE 0x03 << 3
  59:main.c        **** #define ITG3200_42HZ 0x03
  60:main.c        **** #define ITG3200_SIZE 6
  61:main.c        **** 
  62:main.c        **** 
  63:main.c        **** #define HMC5843_ADDRESS 0x3C
  64:main.c        **** //First data address of 6 is XMSB.  Also need to set a configuration register for
  65:main.c        **** //continuous measurement
  66:main.c        **** #define HMC5843_REGISTER_XMSB 0x03
  67:main.c        **** #define HMC5843_REGISTER_MEASMODE 0x02
  68:main.c        **** #define HMC5843_MEASMODE_CONT 0x00
  69:main.c        **** #define HMC5843_SIZE 6
  70:main.c        **** 
  71:main.c        **** 
  72:main.c        **** tdma_info tx_tdma_fd;
  73:main.c        **** tdma_info rx_tdma_fd;
  74:main.c        **** 
  75:main.c        **** uint8_t i2c_buf[16];
  76:main.c        **** uint8_t tx_buf[TDMA_MAX_PKT_SIZE];
  77:main.c        **** uint8_t rx_buf[TDMA_MAX_PKT_SIZE];
  78:main.c        **** uint8_t tx_len;
  79:main.c        **** unsigned int sequenceNo; 
  80:main.c        **** bool packetReady;
  81:main.c        **** uint16_t mac_address;
  82:main.c        **** 
  83:main.c        **** uint8_t aes_key[] = {0x00,0x11,0x22,0x33,0x44,0x55,0x66,0x77,0x88,0x99,0xaa,0xbb,0xcc,0xdd,0xee, 0x
  84:main.c        **** 
  85:main.c        **** 
  86:main.c        **** unsigned char TWI_Act_On_Failure_In_Last_Transmission ( unsigned char TWIerrorMsg )
  87:main.c        **** {
  88:main.c        ****                     // A failure has occurred, use TWIerrorMsg to determine the nature of the failu
  89:main.c        ****                     // and take appropriate actions.
  90:main.c        ****                     // Se header file for a list of possible failures messages.
  91:main.c        ****                     
  92:main.c        ****                     // Here is a simple sample, where if received a NACK on the slave address,
  93:main.c        ****                     // then a retransmission will be initiated.
  94:main.c        **** if ( (TWIerrorMsg == TWI_MTX_ADR_NACK) | (TWIerrorMsg == TWI_MRX_ADR_NACK) ){
  95:main.c        ****     TWI_Start_Transceiver();
  96:main.c        **** }
  97:main.c        **** printf("%c \n",TWIerrorMsg);
  98:main.c        ****     
  99:main.c        ****   return TWIerrorMsg; 
 100:main.c        **** }
 101:main.c        **** 
 102:main.c        **** 
 103:main.c        **** 
 104:main.c        **** 
 105:main.c        **** NRK_STK Stack1[NRK_APP_STACKSIZE];
 106:main.c        **** nrk_task_type TaskOne;
 107:main.c        **** void task_imu(void);
 108:main.c        **** 
 109:main.c        **** NRK_STK rx_task_stack[NRK_APP_STACKSIZE];
 110:main.c        **** nrk_task_type rx_task_info;
 111:main.c        **** void rx_task (void);
 112:main.c        **** 
 113:main.c        **** NRK_STK tx_task_stack[NRK_APP_STACKSIZE];
 114:main.c        **** nrk_task_type tx_task_info;
 115:main.c        **** void tx_task (void);
 116:main.c        **** 
 117:main.c        **** 
 118:main.c        **** void init_adxl345(void);
 119:main.c        **** void init_itg3200(void);
 120:main.c        **** void init_hmc5843(void);
 121:main.c        **** 
 122:main.c        **** void nrk_create_taskset();
 123:main.c        **** 
 124:main.c        **** int
 125:main.c        **** main ()
 126:main.c        **** {
 127:main.c        ****   nrk_setup_ports();
 128:main.c        ****   nrk_setup_uart(UART_BAUDRATE_115K2);
 129:main.c        **** 
 130:main.c        ****     tdma_init (TDMA_CLIENT, DEFAULT_CHANNEL, mac_address);
 131:main.c        **** 
 132:main.c        ****   // tdma_aes_setkey(aes_key);
 133:main.c        ****   // tdma_aes_enable();
 134:main.c        **** 
 135:main.c        ****   tdma_tx_slot_add (mac_address&0xFFFF);
 136:main.c        **** 
 137:main.c        ****   TWI_Master_Initialise();
 138:main.c        ****   sei();
 139:main.c        ****   // init_adxl345();
 140:main.c        ****   // init_itg3200();
 141:main.c        ****   // init_hmc5843();
 142:main.c        ****   /* initialize sequence number, used to sync with master */
 143:main.c        ****   sequenceNo = 0; 
 144:main.c        **** 
 145:main.c        ****   /* initialize tx_buf ready flag */
 146:main.c        ****   packetReady = true;
 147:main.c        ****   
 148:main.c        ****   nrk_init();
 149:main.c        **** 
 150:main.c        ****   mac_address = DEFAULT_CLIENT_MAC;
 151:main.c        **** 
 152:main.c        ****   // if a mac address is defined during compilation
 153:main.c        ****   #ifdef CLIENT_MAC
 154:main.c        ****   mac_address = CLIENT_MAC;
 155:main.c        ****   #endif
 156:main.c        **** 
 157:main.c        ****   nrk_led_clr(ORANGE_LED);
 158:main.c        ****   nrk_led_clr(BLUE_LED);
 159:main.c        ****   nrk_led_clr(GREEN_LED);
 160:main.c        ****   nrk_led_clr(RED_LED);
 161:main.c        ****  
 162:main.c        ****   nrk_time_set(0,0);
 163:main.c        ****   nrk_create_taskset();
 164:main.c        ****   nrk_start();
 165:main.c        ****   
 166:main.c        ****   return 0;
 167:main.c        **** }
 168:main.c        **** 
 169:main.c        **** void init_itg3200() {
 170:main.c        ****     /* put in standby mode while we change fifo control bits */
 171:main.c        ****   i2c_buf[0] = ITG3200_ADDRESS | FALSE<<TWI_READ_BIT;
 172:main.c        ****   i2c_buf[1] = ITG3200_REGISTER_DLPF;
 173:main.c        ****   i2c_buf[2] = ITG3200_FULLSCALE | ITG3200_42HZ;
 174:main.c        ****   TWI_Start_Transceiver_With_Data(i2c_buf, 3);
 175:main.c        **** }
 176:main.c        **** 
 177:main.c        **** void init_hmc5843() {
 178:main.c        ****     /* put in standby mode while we change fifo control bits */
 179:main.c        ****   i2c_buf[0] = HMC5843_ADDRESS | FALSE<<TWI_READ_BIT;
 180:main.c        ****   i2c_buf[1] = HMC5843_REGISTER_MEASMODE;
 181:main.c        ****   i2c_buf[2] = HMC5843_MEASMODE_CONT;
 182:main.c        ****   TWI_Start_Transceiver_With_Data(i2c_buf, 3);
 183:main.c        **** }
 184:main.c        **** 
 185:main.c        **** 
 186:main.c        **** void init_adxl345() {
 187:main.c        ****   unsigned int read = 0;
 188:main.c        **** 
 189:main.c        ****   /* put in standby mode while we change fifo control bits */
 190:main.c        ****   i2c_buf[0] = ADXL345_ADDRESS | FALSE<<TWI_READ_BIT;
 191:main.c        ****   i2c_buf[1] = ADXL_REGISTER_PWRCTL;
 192:main.c        ****   i2c_buf[2] = ADXL_PWRCTL_STBY;
 193:main.c        ****   TWI_Start_Transceiver_With_Data(i2c_buf, 3);
 194:main.c        **** 
 195:main.c        ****   /* set the fifo mode to stream */
 196:main.c        ****   i2c_buf[0] = ADXL345_ADDRESS | FALSE<<TWI_READ_BIT;
 197:main.c        ****   i2c_buf[1] = ADXL_REGISTER_FIFOCTL;
 198:main.c        ****   i2c_buf[2] = ADXL_FIFOCTL_STREAM;
 199:main.c        ****   TWI_Start_Transceiver_With_Data(i2c_buf,3);
 200:main.c        **** 
 201:main.c        **** 
 202:main.c        ****   /* set to measure mode */
 203:main.c        ****   i2c_buf[0] = ADXL345_ADDRESS | FALSE<<TWI_READ_BIT;
 204:main.c        ****   i2c_buf[1] = ADXL_REGISTER_PWRCTL;
 205:main.c        ****   i2c_buf[2] = ADXL_PWRCTL_MEASURE;
 206:main.c        ****   TWI_Start_Transceiver_With_Data(i2c_buf, 3);
 207:main.c        **** }
 208:main.c        **** 
 209:main.c        **** void task_imu(){
 210:main.c        ****   unsigned int i;
 211:main.c        ****   unsigned int count;
 212:main.c        ****   
 213:main.c        ****   while(1){
 214:main.c        ****     packetReady = false;
 215:main.c        ****     i = 0;
 216:main.c        ****     tx_buf[i++] = sequenceNo++;
 217:main.c        **** 
 218:main.c        ****     i2c_buf[0] = (ADXL345_ADDRESS) | (FALSE<<TWI_READ_BIT);
 219:main.c        ****     i2c_buf[1] = ADXL345_REGISTER_XLSB;
 220:main.c        ****     TWI_Start_Transceiver_With_Data(i2c_buf, 2);
 221:main.c        **** 
 222:main.c        ****     /* Read first byte */
 223:main.c        ****     i2c_buf[0] = (ADXL345_ADDRESS) | (TRUE<<TWI_READ_BIT);
 224:main.c        ****     TWI_Start_Transceiver_With_Data(i2c_buf, 7);
 225:main.c        **** 
 226:main.c        ****     for (count = 0; count < ADXL_SIZE; count++){
 227:main.c        ****       tx_buf[i++] = i2c_buf[count+1];
 228:main.c        ****     }
 229:main.c        **** 
 230:main.c        ****     i2c_buf[0] = (ITG3200_ADDRESS) | (FALSE<<TWI_READ_BIT);
 231:main.c        ****     i2c_buf[1] = ITG3200_REGISTER_XMSB;
 232:main.c        ****     TWI_Start_Transceiver_With_Data(i2c_buf, 2);
 233:main.c        **** 
 234:main.c        ****     /* Read first byte */
 235:main.c        ****     i2c_buf[0] = (ITG3200_ADDRESS) | (TRUE<<TWI_READ_BIT);
 236:main.c        ****     TWI_Start_Transceiver_With_Data(i2c_buf, 7);
 237:main.c        **** 
 238:main.c        ****     for (count = 0; count < ITG3200_SIZE; count++){
 239:main.c        ****       tx_buf[i++] = i2c_buf[count+1];
 240:main.c        ****     }
 241:main.c        **** 
 242:main.c        ****     i2c_buf[0] = (HMC5843_ADDRESS) | (FALSE<<TWI_READ_BIT);
 243:main.c        ****     i2c_buf[1] = HMC5843_REGISTER_XMSB;
 244:main.c        ****     TWI_Start_Transceiver_With_Data(i2c_buf, 2);
 245:main.c        **** 
 246:main.c        ****     /* Read first byte */
 247:main.c        ****     i2c_buf[0] = (HMC5843_ADDRESS) | (TRUE<<TWI_READ_BIT);
 248:main.c        ****     TWI_Start_Transceiver_With_Data(i2c_buf, 7);
 249:main.c        **** 
 250:main.c        ****     for (count = 0; count < HMC5843_SIZE; count++){
 251:main.c        ****       tx_buf[i++] = i2c_buf[count+1];
 252:main.c        ****     }
 253:main.c        ****     tx_len = i;
 254:main.c        ****     packetReady = true;
 255:main.c        ****     nrk_wait_until_next_period();
 256:main.c        ****   }
 257:main.c        **** }
 258:main.c        **** 
 259:main.c        **** 
 260:main.c        **** void tx_task ()
 261:main.c        **** {
 350               	.LM0:
 351               	.LFBB1:
 352               	/* prologue: function */
 353               	/* frame size = 0 */
 354               	/* stack size = 0 */
 355               	.L__stack_usage = 0
 262:main.c        ****   int8_t v;
 263:main.c        ****   uint8_t len, cnt;
 264:main.c        **** 
 265:main.c        **** 
 266:main.c        ****   printf ("Tx Task PID=%u\r\n", nrk_get_pid ());
 357               	.LM1:
 358 0000 0E94 0000 		call nrk_get_pid
 359 0004 1F92      		push __zero_reg__
 360 0006 8F93      		push r24
 361 0008 80E0      		ldi r24,lo8(.LC0)
 362 000a 90E0      		ldi r25,hi8(.LC0)
 363 000c 9F93      		push r25
 364 000e 8F93      		push r24
 365 0010 0E94 0000 		call printf
 267:main.c        **** 
 268:main.c        ****   while (!tdma_started())
 367               	.LM2:
 368 0014 0F90      		pop __tmp_reg__
 369 0016 0F90      		pop __tmp_reg__
 370 0018 0F90      		pop __tmp_reg__
 371 001a 0F90      		pop __tmp_reg__
 372               	.L2:
 373 001c 0E94 0000 		call tdma_started
 374 0020 8111      		cpse r24,__zero_reg__
 375 0022 00C0      		rjmp .L8
 269:main.c        ****     nrk_wait_until_next_period ();
 377               	.LM3:
 378 0024 0E94 0000 		call nrk_wait_until_next_period
 379 0028 00C0      		rjmp .L2
 380               	.L8:
 270:main.c        **** 
 271:main.c        ****   cnt = 0;
 272:main.c        **** 
 273:main.c        ****   while (1) {
 274:main.c        **** 
 275:main.c        ****     // if sensor data hasn't been gathered yet
 276:main.c        ****     // if (!packetReady)
 277:main.c        ****     //   nrk_wait_until_next_period();
 278:main.c        **** 
 279:main.c        ****     sprintf(tx_buf,"Hey guys\r\n",8);
 382               	.LM4:
 383 002a C8E0      		ldi r28,lo8(8)
 384 002c 00E0      		ldi r16,lo8(.LC1)
 385 002e 10E0      		ldi r17,hi8(.LC1)
 386 0030 80E0      		ldi r24,lo8(tx_buf)
 387 0032 E82E      		mov r14,r24
 388 0034 80E0      		ldi r24,hi8(tx_buf)
 389 0036 F82E      		mov r15,r24
 390               	.L4:
 391 0038 1F92      		push __zero_reg__
 392 003a CF93      		push r28
 393 003c 1F93      		push r17
 394 003e 0F93      		push r16
 395 0040 FF92      		push r15
 396 0042 EF92      		push r14
 397 0044 0E94 0000 		call sprintf
 280:main.c        ****     tx_len = 8;
 399               	.LM5:
 400 0048 C093 0000 		sts tx_len,r28
 281:main.c        ****     v = tdma_send (&tx_tdma_fd, &tx_buf, tx_len, TDMA_BLOCKING);
 402               	.LM6:
 403 004c 20E0      		ldi r18,0
 404 004e 48E0      		ldi r20,lo8(8)
 405 0050 60E0      		ldi r22,lo8(tx_buf)
 406 0052 70E0      		ldi r23,hi8(tx_buf)
 407 0054 80E0      		ldi r24,lo8(tx_tdma_fd)
 408 0056 90E0      		ldi r25,hi8(tx_tdma_fd)
 409 0058 0E94 0000 		call tdma_send
 282:main.c        ****     if (v == NRK_OK) {
 411               	.LM7:
 412 005c 0F90      		pop __tmp_reg__
 413 005e 0F90      		pop __tmp_reg__
 414 0060 0F90      		pop __tmp_reg__
 415 0062 0F90      		pop __tmp_reg__
 416 0064 0F90      		pop __tmp_reg__
 417 0066 0F90      		pop __tmp_reg__
 418 0068 8130      		cpi r24,lo8(1)
 419 006a 01F4      		brne .L5
 283:main.c        ****       nrk_kprintf (PSTR ("App tx_buf Sent\r\n"));
 421               	.LM8:
 422 006c 80E0      		ldi r24,lo8(__c.3554)
 423 006e 90E0      		ldi r25,hi8(__c.3554)
 424 0070 0E94 0000 		call nrk_kprintf
 425 0074 00C0      		rjmp .L4
 426               	.L5:
 284:main.c        ****     }
 285:main.c        ****     else
 286:main.c        ****       printf("packet receiving error!\r\n");
 428               	.LM9:
 429 0076 80E0      		ldi r24,lo8(.LC2)
 430 0078 90E0      		ldi r25,hi8(.LC2)
 431 007a 0E94 0000 		call puts
 432 007e 00C0      		rjmp .L4
 434               	.Lscope1:
 436               		.stabd	78,0,0
 437               		.section	.rodata.str1.1
 438               	.LC3:
 439 0035 2563 200A 		.string	"%c \n"
 439      00
 440               		.text
 443               	.global	TWI_Act_On_Failure_In_Last_Transmission
 445               	TWI_Act_On_Failure_In_Last_Transmission:
 446               		.stabd	46,0,0
  87:main.c        ****                     // A failure has occurred, use TWIerrorMsg to determine the nature of the failu
 448               	.LM10:
 449               	.LFBB2:
 450 0080 CF93      		push r28
 451               	/* prologue: function */
 452               	/* frame size = 0 */
 453               	/* stack size = 1 */
 454               	.L__stack_usage = 1
 455 0082 C82F      		mov r28,r24
  94:main.c        ****     TWI_Start_Transceiver();
 457               	.LM11:
 458 0084 8834      		cpi r24,lo8(72)
 459 0086 01F0      		breq .L14
 460 0088 8032      		cpi r24,lo8(32)
 461 008a 01F4      		brne .L10
 462               	.L14:
  95:main.c        **** }
 464               	.LM12:
 465 008c 0E94 0000 		call TWI_Start_Transceiver
 466               	.L10:
  97:main.c        ****     
 468               	.LM13:
 469 0090 1F92      		push __zero_reg__
 470 0092 CF93      		push r28
 471 0094 80E0      		ldi r24,lo8(.LC3)
 472 0096 90E0      		ldi r25,hi8(.LC3)
 473 0098 9F93      		push r25
 474 009a 8F93      		push r24
 475 009c 0E94 0000 		call printf
  99:main.c        **** }
 477               	.LM14:
 478 00a0 0F90      		pop __tmp_reg__
 479 00a2 0F90      		pop __tmp_reg__
 480 00a4 0F90      		pop __tmp_reg__
 481 00a6 0F90      		pop __tmp_reg__
 100:main.c        **** 
 483               	.LM15:
 484 00a8 8C2F      		mov r24,r28
 485               	/* epilogue start */
 486 00aa CF91      		pop r28
 487 00ac 0895      		ret
 489               	.Lscope2:
 491               		.stabd	78,0,0
 493               	.global	init_itg3200
 495               	init_itg3200:
 496               		.stabd	46,0,0
 169:main.c        ****     /* put in standby mode while we change fifo control bits */
 498               	.LM16:
 499               	.LFBB3:
 500               	/* prologue: function */
 501               	/* frame size = 0 */
 502               	/* stack size = 0 */
 503               	.L__stack_usage = 0
 171:main.c        ****   i2c_buf[1] = ITG3200_REGISTER_DLPF;
 505               	.LM17:
 506 00ae E0E0      		ldi r30,lo8(i2c_buf)
 507 00b0 F0E0      		ldi r31,hi8(i2c_buf)
 508 00b2 80ED      		ldi r24,lo8(-48)
 509 00b4 8083      		st Z,r24
 172:main.c        ****   i2c_buf[2] = ITG3200_FULLSCALE | ITG3200_42HZ;
 511               	.LM18:
 512 00b6 86E1      		ldi r24,lo8(22)
 513 00b8 8183      		std Z+1,r24
 173:main.c        ****   TWI_Start_Transceiver_With_Data(i2c_buf, 3);
 515               	.LM19:
 516 00ba 8BE1      		ldi r24,lo8(27)
 517 00bc 8283      		std Z+2,r24
 174:main.c        **** }
 519               	.LM20:
 520 00be 63E0      		ldi r22,lo8(3)
 521 00c0 CF01      		movw r24,r30
 522 00c2 0C94 0000 		jmp TWI_Start_Transceiver_With_Data
 524               	.Lscope3:
 526               		.stabd	78,0,0
 528               	.global	init_hmc5843
 530               	init_hmc5843:
 531               		.stabd	46,0,0
 177:main.c        ****     /* put in standby mode while we change fifo control bits */
 533               	.LM21:
 534               	.LFBB4:
 535               	/* prologue: function */
 536               	/* frame size = 0 */
 537               	/* stack size = 0 */
 538               	.L__stack_usage = 0
 179:main.c        ****   i2c_buf[1] = HMC5843_REGISTER_MEASMODE;
 540               	.LM22:
 541 00c6 E0E0      		ldi r30,lo8(i2c_buf)
 542 00c8 F0E0      		ldi r31,hi8(i2c_buf)
 543 00ca 8CE3      		ldi r24,lo8(60)
 544 00cc 8083      		st Z,r24
 180:main.c        ****   i2c_buf[2] = HMC5843_MEASMODE_CONT;
 546               	.LM23:
 547 00ce 82E0      		ldi r24,lo8(2)
 548 00d0 8183      		std Z+1,r24
 181:main.c        ****   TWI_Start_Transceiver_With_Data(i2c_buf, 3);
 550               	.LM24:
 551 00d2 1282      		std Z+2,__zero_reg__
 182:main.c        **** }
 553               	.LM25:
 554 00d4 63E0      		ldi r22,lo8(3)
 555 00d6 CF01      		movw r24,r30
 556 00d8 0C94 0000 		jmp TWI_Start_Transceiver_With_Data
 558               	.Lscope4:
 560               		.stabd	78,0,0
 562               	.global	init_adxl345
 564               	init_adxl345:
 565               		.stabd	46,0,0
 186:main.c        ****   unsigned int read = 0;
 567               	.LM26:
 568               	.LFBB5:
 569 00dc 0F93      		push r16
 570 00de 1F93      		push r17
 571 00e0 CF93      		push r28
 572 00e2 DF93      		push r29
 573               	/* prologue: function */
 574               	/* frame size = 0 */
 575               	/* stack size = 4 */
 576               	.L__stack_usage = 4
 190:main.c        ****   i2c_buf[1] = ADXL_REGISTER_PWRCTL;
 578               	.LM27:
 579 00e4 C0E0      		ldi r28,lo8(i2c_buf)
 580 00e6 D0E0      		ldi r29,hi8(i2c_buf)
 581 00e8 16EA      		ldi r17,lo8(-90)
 582 00ea 1883      		st Y,r17
 191:main.c        ****   i2c_buf[2] = ADXL_PWRCTL_STBY;
 584               	.LM28:
 585 00ec 0DE2      		ldi r16,lo8(45)
 586 00ee 0983      		std Y+1,r16
 192:main.c        ****   TWI_Start_Transceiver_With_Data(i2c_buf, 3);
 588               	.LM29:
 589 00f0 1A82      		std Y+2,__zero_reg__
 193:main.c        **** 
 591               	.LM30:
 592 00f2 63E0      		ldi r22,lo8(3)
 593 00f4 CE01      		movw r24,r28
 594 00f6 0E94 0000 		call TWI_Start_Transceiver_With_Data
 196:main.c        ****   i2c_buf[1] = ADXL_REGISTER_FIFOCTL;
 596               	.LM31:
 597 00fa 1883      		st Y,r17
 197:main.c        ****   i2c_buf[2] = ADXL_FIFOCTL_STREAM;
 599               	.LM32:
 600 00fc 88E3      		ldi r24,lo8(56)
 601 00fe 8983      		std Y+1,r24
 198:main.c        ****   TWI_Start_Transceiver_With_Data(i2c_buf,3);
 603               	.LM33:
 604 0100 80E8      		ldi r24,lo8(-128)
 605 0102 8A83      		std Y+2,r24
 199:main.c        **** 
 607               	.LM34:
 608 0104 63E0      		ldi r22,lo8(3)
 609 0106 CE01      		movw r24,r28
 610 0108 0E94 0000 		call TWI_Start_Transceiver_With_Data
 203:main.c        ****   i2c_buf[1] = ADXL_REGISTER_PWRCTL;
 612               	.LM35:
 613 010c 1883      		st Y,r17
 204:main.c        ****   i2c_buf[2] = ADXL_PWRCTL_MEASURE;
 615               	.LM36:
 616 010e 0983      		std Y+1,r16
 205:main.c        ****   TWI_Start_Transceiver_With_Data(i2c_buf, 3);
 618               	.LM37:
 619 0110 88E0      		ldi r24,lo8(8)
 620 0112 8A83      		std Y+2,r24
 206:main.c        **** }
 622               	.LM38:
 623 0114 63E0      		ldi r22,lo8(3)
 624 0116 CE01      		movw r24,r28
 625               	/* epilogue start */
 207:main.c        **** 
 627               	.LM39:
 628 0118 DF91      		pop r29
 629 011a CF91      		pop r28
 630 011c 1F91      		pop r17
 631 011e 0F91      		pop r16
 206:main.c        **** }
 633               	.LM40:
 634 0120 0C94 0000 		jmp TWI_Start_Transceiver_With_Data
 636               	.Lscope5:
 638               		.stabd	78,0,0
 640               	.global	task_imu
 642               	task_imu:
 643               		.stabd	46,0,0
 209:main.c        ****   unsigned int i;
 645               	.LM41:
 646               	.LFBB6:
 647 0124 CF93      		push r28
 648 0126 DF93      		push r29
 649 0128 00D0      		rcall .
 650 012a CDB7      		in r28,__SP_L__
 651 012c DEB7      		in r29,__SP_H__
 652               	/* prologue: function */
 653               	/* frame size = 2 */
 654               	/* stack size = 4 */
 655               	.L__stack_usage = 4
 218:main.c        ****     i2c_buf[1] = ADXL345_REGISTER_XLSB;
 657               	.LM42:
 658 012e 86EA      		ldi r24,lo8(-90)
 659 0130 F82E      		mov r15,r24
 219:main.c        ****     TWI_Start_Transceiver_With_Data(i2c_buf, 2);
 661               	.LM43:
 662 0132 92E3      		ldi r25,lo8(50)
 663 0134 E92E      		mov r14,r25
 223:main.c        ****     TWI_Start_Transceiver_With_Data(i2c_buf, 7);
 665               	.LM44:
 666 0136 27EA      		ldi r18,lo8(-89)
 667 0138 D22E      		mov r13,r18
 230:main.c        ****     i2c_buf[1] = ITG3200_REGISTER_XMSB;
 669               	.LM45:
 670 013a 30ED      		ldi r19,lo8(-48)
 671 013c C32E      		mov r12,r19
 231:main.c        ****     TWI_Start_Transceiver_With_Data(i2c_buf, 2);
 673               	.LM46:
 674 013e 4DE1      		ldi r20,lo8(29)
 675 0140 B42E      		mov r11,r20
 235:main.c        ****     TWI_Start_Transceiver_With_Data(i2c_buf, 7);
 677               	.LM47:
 678 0142 51ED      		ldi r21,lo8(-47)
 679 0144 A52E      		mov r10,r21
 242:main.c        ****     i2c_buf[1] = HMC5843_REGISTER_XMSB;
 681               	.LM48:
 682 0146 6CE3      		ldi r22,lo8(60)
 683 0148 962E      		mov r9,r22
 243:main.c        ****     TWI_Start_Transceiver_With_Data(i2c_buf, 2);
 685               	.LM49:
 686 014a 73E0      		ldi r23,lo8(3)
 687 014c 872E      		mov r8,r23
 247:main.c        ****     TWI_Start_Transceiver_With_Data(i2c_buf, 7);
 689               	.LM50:
 690 014e EDE3      		ldi r30,lo8(61)
 691 0150 7E2E      		mov r7,r30
 253:main.c        ****     packetReady = true;
 693               	.LM51:
 694 0152 03E1      		ldi r16,lo8(19)
 254:main.c        ****     nrk_wait_until_next_period();
 696               	.LM52:
 697 0154 11E0      		ldi r17,lo8(1)
 698               	.L29:
 214:main.c        ****     i = 0;
 700               	.LM53:
 701 0156 1092 0000 		sts packetReady,__zero_reg__
 216:main.c        **** 
 703               	.LM54:
 704 015a 8091 0000 		lds r24,sequenceNo
 705 015e 9091 0000 		lds r25,sequenceNo+1
 706 0162 9C01      		movw r18,r24
 707 0164 2F5F      		subi r18,-1
 708 0166 3F4F      		sbci r19,-1
 709 0168 3093 0000 		sts sequenceNo+1,r19
 710 016c 2093 0000 		sts sequenceNo,r18
 711 0170 8093 0000 		sts tx_buf,r24
 218:main.c        ****     i2c_buf[1] = ADXL345_REGISTER_XLSB;
 713               	.LM55:
 714 0174 F092 0000 		sts i2c_buf,r15
 219:main.c        ****     TWI_Start_Transceiver_With_Data(i2c_buf, 2);
 716               	.LM56:
 717 0178 E092 0000 		sts i2c_buf+1,r14
 220:main.c        **** 
 719               	.LM57:
 720 017c 62E0      		ldi r22,lo8(2)
 721 017e 80E0      		ldi r24,lo8(i2c_buf)
 722 0180 90E0      		ldi r25,hi8(i2c_buf)
 723 0182 0E94 0000 		call TWI_Start_Transceiver_With_Data
 223:main.c        ****     TWI_Start_Transceiver_With_Data(i2c_buf, 7);
 725               	.LM58:
 726 0186 D092 0000 		sts i2c_buf,r13
 224:main.c        **** 
 728               	.LM59:
 729 018a 67E0      		ldi r22,lo8(7)
 730 018c 80E0      		ldi r24,lo8(i2c_buf)
 731 018e 90E0      		ldi r25,hi8(i2c_buf)
 732 0190 0E94 0000 		call TWI_Start_Transceiver_With_Data
 216:main.c        **** 
 734               	.LM60:
 735 0194 81E0      		ldi r24,lo8(1)
 736 0196 90E0      		ldi r25,0
 737               	.L26:
 227:main.c        ****     }
 739               	.LM61:
 740 0198 2C01      		movw r4,r24
 741 019a 2FEF      		ldi r18,-1
 742 019c 421A      		sub r4,r18
 743 019e 520A      		sbc r5,r18
 744 01a0 FC01      		movw r30,r24
 745 01a2 E050      		subi r30,lo8(-(i2c_buf))
 746 01a4 F040      		sbci r31,hi8(-(i2c_buf))
 747 01a6 2081      		ld r18,Z
 748 01a8 FC01      		movw r30,r24
 749 01aa E050      		subi r30,lo8(-(tx_buf))
 750 01ac F040      		sbci r31,hi8(-(tx_buf))
 751 01ae 2083      		st Z,r18
 752 01b0 C201      		movw r24,r4
 226:main.c        ****       tx_buf[i++] = i2c_buf[count+1];
 754               	.LM62:
 755 01b2 8730      		cpi r24,7
 756 01b4 9105      		cpc r25,__zero_reg__
 757 01b6 01F4      		brne .L26
 230:main.c        ****     i2c_buf[1] = ITG3200_REGISTER_XMSB;
 759               	.LM63:
 760 01b8 C092 0000 		sts i2c_buf,r12
 231:main.c        ****     TWI_Start_Transceiver_With_Data(i2c_buf, 2);
 762               	.LM64:
 763 01bc B092 0000 		sts i2c_buf+1,r11
 232:main.c        **** 
 765               	.LM65:
 766 01c0 62E0      		ldi r22,lo8(2)
 767 01c2 80E0      		ldi r24,lo8(i2c_buf)
 768 01c4 90E0      		ldi r25,hi8(i2c_buf)
 769 01c6 0E94 0000 		call TWI_Start_Transceiver_With_Data
 235:main.c        ****     TWI_Start_Transceiver_With_Data(i2c_buf, 7);
 771               	.LM66:
 772 01ca A092 0000 		sts i2c_buf,r10
 236:main.c        **** 
 774               	.LM67:
 775 01ce 67E0      		ldi r22,lo8(7)
 776 01d0 80E0      		ldi r24,lo8(i2c_buf)
 777 01d2 90E0      		ldi r25,hi8(i2c_buf)
 778 01d4 0E94 0000 		call TWI_Start_Transceiver_With_Data
 779               	.L27:
 239:main.c        ****     }
 781               	.LM68:
 782 01d8 9201      		movw r18,r4
 783 01da 2F5F      		subi r18,-1
 784 01dc 3F4F      		sbci r19,-1
 785 01de F201      		movw r30,r4
 786 01e0 E050      		subi r30,lo8(-(i2c_buf-6))
 787 01e2 F040      		sbci r31,hi8(-(i2c_buf-6))
 788 01e4 8081      		ld r24,Z
 789 01e6 F201      		movw r30,r4
 790 01e8 E050      		subi r30,lo8(-(tx_buf))
 791 01ea F040      		sbci r31,hi8(-(tx_buf))
 792 01ec 8083      		st Z,r24
 793 01ee 2901      		movw r4,r18
 238:main.c        ****       tx_buf[i++] = i2c_buf[count+1];
 795               	.LM69:
 796 01f0 2D30      		cpi r18,13
 797 01f2 3105      		cpc r19,__zero_reg__
 798 01f4 01F4      		brne .L27
 242:main.c        ****     i2c_buf[1] = HMC5843_REGISTER_XMSB;
 800               	.LM70:
 801 01f6 9092 0000 		sts i2c_buf,r9
 243:main.c        ****     TWI_Start_Transceiver_With_Data(i2c_buf, 2);
 803               	.LM71:
 804 01fa 8092 0000 		sts i2c_buf+1,r8
 244:main.c        **** 
 806               	.LM72:
 807 01fe 62E0      		ldi r22,lo8(2)
 808 0200 80E0      		ldi r24,lo8(i2c_buf)
 809 0202 90E0      		ldi r25,hi8(i2c_buf)
 810 0204 2983      		std Y+1,r18
 811 0206 3A83      		std Y+2,r19
 812 0208 0E94 0000 		call TWI_Start_Transceiver_With_Data
 247:main.c        ****     TWI_Start_Transceiver_With_Data(i2c_buf, 7);
 814               	.LM73:
 815 020c 7092 0000 		sts i2c_buf,r7
 248:main.c        **** 
 817               	.LM74:
 818 0210 67E0      		ldi r22,lo8(7)
 819 0212 80E0      		ldi r24,lo8(i2c_buf)
 820 0214 90E0      		ldi r25,hi8(i2c_buf)
 821 0216 0E94 0000 		call TWI_Start_Transceiver_With_Data
 822 021a 3A81      		ldd r19,Y+2
 823 021c 2981      		ldd r18,Y+1
 824               	.L28:
 825 021e F901      		movw r30,r18
 826 0220 E050      		subi r30,lo8(-(i2c_buf-12))
 827 0222 F040      		sbci r31,hi8(-(i2c_buf-12))
 251:main.c        ****     }
 829               	.LM75:
 830 0224 8081      		ld r24,Z
 831 0226 F901      		movw r30,r18
 832 0228 E050      		subi r30,lo8(-(tx_buf))
 833 022a F040      		sbci r31,hi8(-(tx_buf))
 834 022c 8083      		st Z,r24
 835 022e 2F5F      		subi r18,-1
 836 0230 3F4F      		sbci r19,-1
 250:main.c        ****       tx_buf[i++] = i2c_buf[count+1];
 838               	.LM76:
 839 0232 2331      		cpi r18,19
 840 0234 3105      		cpc r19,__zero_reg__
 841 0236 01F4      		brne .L28
 253:main.c        ****     packetReady = true;
 843               	.LM77:
 844 0238 0093 0000 		sts tx_len,r16
 254:main.c        ****     nrk_wait_until_next_period();
 846               	.LM78:
 847 023c 1093 0000 		sts packetReady,r17
 255:main.c        ****   }
 849               	.LM79:
 850 0240 0E94 0000 		call nrk_wait_until_next_period
 256:main.c        **** }
 852               	.LM80:
 853 0244 00C0      		rjmp .L29
 855               	.Lscope6:
 857               		.stabd	78,0,0
 858               		.section	.rodata.str1.1
 859               	.LC4:
 860 003a 2564 0D0A 		.string	"%d\r\n"
 860      00
 861               	.LC5:
 862 003f 5258 2054 		.string	"RX Task PID=%u\r\n"
 862      6173 6B20 
 862      5049 443D 
 862      2575 0D0A 
 862      00
 863               		.text
 865               	.global	rx_task
 867               	rx_task:
 868               		.stabd	46,0,0
 287:main.c        ****   }
 288:main.c        **** }
 289:main.c        **** 
 290:main.c        **** void rx_task ()
 291:main.c        **** {
 870               	.LM81:
 871               	.LFBB7:
 872 0246 CF93      		push r28
 873 0248 DF93      		push r29
 874 024a 1F92      		push __zero_reg__
 875 024c CDB7      		in r28,__SP_L__
 876 024e DEB7      		in r29,__SP_H__
 877               	/* prologue: function */
 878               	/* frame size = 1 */
 879               	/* stack size = 3 */
 880               	.L__stack_usage = 3
 292:main.c        ****   nrk_time_t t;
 293:main.c        ****   uint16_t cnt;
 294:main.c        ****   int8_t v;
 295:main.c        ****   uint8_t len, i;
 296:main.c        **** 
 297:main.c        **** 
 298:main.c        ****   cnt = 0;
 299:main.c        ****   nrk_kprintf (PSTR ("Nano-RK Version "));
 882               	.LM82:
 883 0250 80E0      		ldi r24,lo8(__c.3564)
 884 0252 90E0      		ldi r25,hi8(__c.3564)
 885 0254 0E94 0000 		call nrk_kprintf
 300:main.c        ****   printf ("%d\r\n", NRK_VERSION);
 887               	.LM83:
 888 0258 1F92      		push __zero_reg__
 889 025a 85E6      		ldi r24,lo8(101)
 890 025c 8F93      		push r24
 891 025e 80E0      		ldi r24,lo8(.LC4)
 892 0260 90E0      		ldi r25,hi8(.LC4)
 893 0262 9F93      		push r25
 894 0264 8F93      		push r24
 895 0266 0E94 0000 		call printf
 301:main.c        **** 
 302:main.c        **** 
 303:main.c        ****   printf ("RX Task PID=%u\r\n", nrk_get_pid ());
 897               	.LM84:
 898 026a 0E94 0000 		call nrk_get_pid
 899 026e 1F92      		push __zero_reg__
 900 0270 8F93      		push r24
 901 0272 80E0      		ldi r24,lo8(.LC5)
 902 0274 90E0      		ldi r25,hi8(.LC5)
 903 0276 9F93      		push r25
 904 0278 8F93      		push r24
 905 027a 0E94 0000 		call printf
 304:main.c        ****   // t.secs = 5;
 305:main.c        ****   // t.nano_secs = 0;
 306:main.c        **** 
 307:main.c        ****   // // setup a software watch dog timer
 308:main.c        ****   // nrk_sw_wdt_init(0, &t, NULL);
 309:main.c        ****   // nrk_sw_wdt_start(0);
 310:main.c        **** 
 311:main.c        **** 
 312:main.c        ****   tdma_init (TDMA_CLIENT, DEFAULT_CHANNEL, mac_address);
 907               	.LM85:
 908 027e 4091 0000 		lds r20,mac_address
 909 0282 5091 0000 		lds r21,mac_address+1
 910 0286 6DE0      		ldi r22,lo8(13)
 911 0288 82E0      		ldi r24,lo8(2)
 912 028a 0E94 0000 		call tdma_init
 313:main.c        **** 
 314:main.c        ****   // tdma_aes_setkey(aes_key);
 315:main.c        ****   // tdma_aes_enable();
 316:main.c        **** 
 317:main.c        **** 
 318:main.c        **** 
 319:main.c        ****   while (!tdma_started ())
 914               	.LM86:
 915 028e 0FB6      		in __tmp_reg__,__SREG__
 916 0290 F894      		cli
 917 0292 DEBF      		out __SP_H__,r29
 918 0294 0FBE      		out __SREG__,__tmp_reg__
 919 0296 CDBF      		out __SP_L__,r28
 920               	.L34:
 921 0298 0E94 0000 		call tdma_started
 922 029c 8111      		cpse r24,__zero_reg__
 923 029e 00C0      		rjmp .L45
 320:main.c        ****     nrk_wait_until_next_period ();
 925               	.LM87:
 926 02a0 0E94 0000 		call nrk_wait_until_next_period
 927 02a4 00C0      		rjmp .L34
 928               	.L45:
 321:main.c        **** 
 322:main.c        ****   v = tdma_tx_slot_add (mac_address&0xFFFF);
 930               	.LM88:
 931 02a6 8091 0000 		lds r24,mac_address
 932 02aa 9091 0000 		lds r25,mac_address+1
 933 02ae 0E94 0000 		call tdma_tx_slot_add
 323:main.c        **** 
 324:main.c        ****   if (v != NRK_OK)
 935               	.LM89:
 936 02b2 8130      		cpi r24,lo8(1)
 937 02b4 01F0      		breq .L38
 325:main.c        ****     nrk_kprintf (PSTR ("Could not add slot!\r\n"));
 939               	.LM90:
 940 02b6 80E0      		ldi r24,lo8(__c.3569)
 941 02b8 90E0      		ldi r25,hi8(__c.3569)
 942 02ba 0E94 0000 		call nrk_kprintf
 943               	.L38:
 326:main.c        **** 
 327:main.c        ****   while (1) {
 328:main.c        ****     // Update watchdog timer
 329:main.c        ****     // nrk_sw_wdt_update(0);
 330:main.c        ****     v = tdma_recv (&rx_tdma_fd, &rx_buf, &len, TDMA_BLOCKING);
 945               	.LM91:
 946 02be 20E0      		ldi r18,0
 947 02c0 AE01      		movw r20,r28
 948 02c2 4F5F      		subi r20,-1
 949 02c4 5F4F      		sbci r21,-1
 950 02c6 60E0      		ldi r22,lo8(rx_buf)
 951 02c8 70E0      		ldi r23,hi8(rx_buf)
 952 02ca 80E0      		ldi r24,lo8(rx_tdma_fd)
 953 02cc 90E0      		ldi r25,hi8(rx_tdma_fd)
 954 02ce 0E94 0000 		call tdma_recv
 331:main.c        ****     if (v == NRK_OK) {
 956               	.LM92:
 957 02d2 8130      		cpi r24,lo8(1)
 958 02d4 01F0      		breq .L37
 332:main.c        ****       // printf ("src: %u\r\nrssi: %d\r\n", rx_tdma_fd.src, rx_tdma_fd.rssi);
 333:main.c        ****       // printf ("slot: %u\r\n", rx_tdma_fd.slot);
 334:main.c        ****       // printf ("cycle len: %u\r\n", rx_tdma_fd.cycle_size);
 335:main.c        ****       // printf ("len: %u\r\npayload: ", len);
 336:main.c        ****       // for (i = 0; i < len; i++)
 337:main.c        ****         // printf ("%c", rx_buf[i]);
 338:main.c        ****       // printf ("\r\n");
 339:main.c        ****     }
 340:main.c        ****     else
 341:main.c        ****       printf("packet receiving error!\r\n");
 960               	.LM93:
 961 02d6 80E0      		ldi r24,lo8(.LC2)
 962 02d8 90E0      		ldi r25,hi8(.LC2)
 963 02da 0E94 0000 		call puts
 964               	.L37:
 342:main.c        **** 
 343:main.c        ****      nrk_wait_until_next_period();
 966               	.LM94:
 967 02de 0E94 0000 		call nrk_wait_until_next_period
 344:main.c        ****   }
 969               	.LM95:
 970 02e2 00C0      		rjmp .L38
 975               	.Lscope7:
 977               		.stabd	78,0,0
 979               	.global	nrk_create_taskset
 981               	nrk_create_taskset:
 982               		.stabd	46,0,0
 345:main.c        **** }
 346:main.c        **** 
 347:main.c        **** 
 348:main.c        **** 
 349:main.c        **** void
 350:main.c        **** nrk_create_taskset()
 351:main.c        **** {
 984               	.LM96:
 985               	.LFBB8:
 986               	/* prologue: function */
 987               	/* frame size = 0 */
 988               	/* stack size = 0 */
 989               	.L__stack_usage = 0
 352:main.c        ****   // nrk_task_set_entry_function( &TaskOne, task_imu);
 353:main.c        ****   // nrk_task_set_stk( &TaskOne, Stack1, NRK_APP_STACKSIZE);
 354:main.c        ****   // TaskOne.prio = 1;
 355:main.c        ****   // TaskOne.FirstActivation = TRUE;
 356:main.c        ****   // TaskOne.Type = BASIC_TASK;
 357:main.c        ****   // TaskOne.SchType = PREEMPTIVE;
 358:main.c        ****   // TaskOne.period.secs = 0;
 359:main.c        ****   // TaskOne.period.nano_secs = 25 * NANOS_PER_MS;
 360:main.c        ****   // TaskOne.cpu_reserve.secs = 0;
 361:main.c        ****   // TaskOne.cpu_reserve.nano_secs = 30 * NANOS_PER_MS;
 362:main.c        ****   // TaskOne.offset.secs = 1;
 363:main.c        ****   // TaskOne.offset.nano_secs= 0;
 364:main.c        ****   // nrk_activate_task (&TaskOne);
 365:main.c        **** 
 366:main.c        ****   // nrk_task_set_entry_function (&rx_task_info, rx_task);
 367:main.c        ****   // nrk_task_set_stk (&rx_task_info, rx_task_stack, NRK_APP_STACKSIZE);
 368:main.c        ****   // rx_task_info.prio = 1;
 369:main.c        ****   // rx_task_info.FirstActivation = TRUE;
 370:main.c        ****   // rx_task_info.Type = BASIC_TASK;
 371:main.c        ****   // rx_task_info.SchType = PREEMPTIVE;
 372:main.c        ****   // rx_task_info.period.secs = 0;
 373:main.c        ****   // rx_task_info.period.nano_secs = 25 * NANOS_PER_MS;
 374:main.c        ****   // rx_task_info.cpu_reserve.secs = 0;
 375:main.c        ****   // rx_task_info.cpu_reserve.nano_secs = 30 * NANOS_PER_MS;
 376:main.c        ****   // rx_task_info.offset.secs = 0;
 377:main.c        ****   // rx_task_info.offset.nano_secs = 0;
 378:main.c        ****   // nrk_activate_task (&rx_task_info);
 379:main.c        **** 
 380:main.c        ****   nrk_task_set_entry_function (&tx_task_info, tx_task);
 991               	.LM97:
 992 02e4 60E0      		ldi r22,lo8(gs(tx_task))
 993 02e6 70E0      		ldi r23,hi8(gs(tx_task))
 994 02e8 80E0      		ldi r24,lo8(tx_task_info)
 995 02ea 90E0      		ldi r25,hi8(tx_task_info)
 996 02ec 0E94 0000 		call nrk_task_set_entry_function
 381:main.c        ****   nrk_task_set_stk (&tx_task_info, tx_task_stack, NRK_APP_STACKSIZE);
 998               	.LM98:
 999 02f0 40E8      		ldi r20,lo8(-128)
 1000 02f2 50E0      		ldi r21,0
 1001 02f4 60E0      		ldi r22,lo8(tx_task_stack)
 1002 02f6 70E0      		ldi r23,hi8(tx_task_stack)
 1003 02f8 80E0      		ldi r24,lo8(tx_task_info)
 1004 02fa 90E0      		ldi r25,hi8(tx_task_info)
 1005 02fc 0E94 0000 		call nrk_task_set_stk
 382:main.c        ****   tx_task_info.prio = 1;
 1007               	.LM99:
 1008 0300 E0E0      		ldi r30,lo8(tx_task_info)
 1009 0302 F0E0      		ldi r31,hi8(tx_task_info)
 1010 0304 81E0      		ldi r24,lo8(1)
 1011 0306 8087      		std Z+8,r24
 383:main.c        ****   tx_task_info.FirstActivation = TRUE;
 1013               	.LM100:
 1014 0308 8783      		std Z+7,r24
 384:main.c        ****   tx_task_info.Type = BASIC_TASK;
 1016               	.LM101:
 1017 030a 8187      		std Z+9,r24
 385:main.c        ****   tx_task_info.SchType = PREEMPTIVE;
 1019               	.LM102:
 1020 030c 8287      		std Z+10,r24
 386:main.c        ****   tx_task_info.period.secs = 0;
 1022               	.LM103:
 1023 030e 1386      		std Z+11,__zero_reg__
 1024 0310 1486      		std Z+12,__zero_reg__
 1025 0312 1586      		std Z+13,__zero_reg__
 1026 0314 1686      		std Z+14,__zero_reg__
 387:main.c        ****   tx_task_info.period.nano_secs = 25 * NANOS_PER_MS;
 1028               	.LM104:
 1029 0316 80E4      		ldi r24,lo8(64)
 1030 0318 98E7      		ldi r25,lo8(120)
 1031 031a ADE7      		ldi r26,lo8(125)
 1032 031c B1E0      		ldi r27,lo8(1)
 1033 031e 8787      		std Z+15,r24
 1034 0320 908B      		std Z+16,r25
 1035 0322 A18B      		std Z+17,r26
 1036 0324 B28B      		std Z+18,r27
 388:main.c        ****   tx_task_info.cpu_reserve.secs = 0;
 1038               	.LM105:
 1039 0326 138A      		std Z+19,__zero_reg__
 1040 0328 148A      		std Z+20,__zero_reg__
 1041 032a 158A      		std Z+21,__zero_reg__
 1042 032c 168A      		std Z+22,__zero_reg__
 389:main.c        ****   tx_task_info.cpu_reserve.nano_secs = 30 * NANOS_PER_MS;
 1044               	.LM106:
 1045 032e 80E8      		ldi r24,lo8(-128)
 1046 0330 93EC      		ldi r25,lo8(-61)
 1047 0332 A9EC      		ldi r26,lo8(-55)
 1048 0334 B1E0      		ldi r27,lo8(1)
 1049 0336 878B      		std Z+23,r24
 1050 0338 908F      		std Z+24,r25
 1051 033a A18F      		std Z+25,r26
 1052 033c B28F      		std Z+26,r27
 390:main.c        ****   tx_task_info.offset.secs = 0;
 1054               	.LM107:
 1055 033e 138E      		std Z+27,__zero_reg__
 1056 0340 148E      		std Z+28,__zero_reg__
 1057 0342 158E      		std Z+29,__zero_reg__
 1058 0344 168E      		std Z+30,__zero_reg__
 391:main.c        ****   tx_task_info.offset.nano_secs = 0;
 1060               	.LM108:
 1061 0346 178E      		std Z+31,__zero_reg__
 1062 0348 10A2      		std Z+32,__zero_reg__
 1063 034a 11A2      		std Z+33,__zero_reg__
 1064 034c 12A2      		std Z+34,__zero_reg__
 392:main.c        ****   nrk_activate_task (&tx_task_info);
 1066               	.LM109:
 1067 034e CF01      		movw r24,r30
 1068 0350 0E94 0000 		call nrk_activate_task
 393:main.c        **** 
 394:main.c        ****   tdma_task_config ();
 1070               	.LM110:
 1071 0354 0C94 0000 		jmp tdma_task_config
 1073               	.Lscope8:
 1075               		.stabd	78,0,0
 1076               		.section	.text.startup,"ax",@progbits
 1078               	.global	main
 1080               	main:
 1081               		.stabd	46,0,0
 126:main.c        ****   nrk_setup_ports();
 1083               	.LM111:
 1084               	.LFBB9:
 1085               	/* prologue: function */
 1086               	/* frame size = 0 */
 1087               	/* stack size = 0 */
 1088               	.L__stack_usage = 0
 127:main.c        ****   nrk_setup_uart(UART_BAUDRATE_115K2);
 1090               	.LM112:
 1091 0000 0E94 0000 		call nrk_setup_ports
 128:main.c        **** 
 1093               	.LM113:
 1094 0004 80E1      		ldi r24,lo8(16)
 1095 0006 90E0      		ldi r25,0
 1096 0008 0E94 0000 		call nrk_setup_uart
 130:main.c        **** 
 1098               	.LM114:
 1099 000c 4091 0000 		lds r20,mac_address
 1100 0010 5091 0000 		lds r21,mac_address+1
 1101 0014 6DE0      		ldi r22,lo8(13)
 1102 0016 82E0      		ldi r24,lo8(2)
 1103 0018 0E94 0000 		call tdma_init
 135:main.c        **** 
 1105               	.LM115:
 1106 001c 8091 0000 		lds r24,mac_address
 1107 0020 9091 0000 		lds r25,mac_address+1
 1108 0024 0E94 0000 		call tdma_tx_slot_add
 137:main.c        ****   sei();
 1110               	.LM116:
 1111 0028 0E94 0000 		call TWI_Master_Initialise
 138:main.c        ****   // init_adxl345();
 1113               	.LM117:
 1114               	/* #APP */
 1115               	 ;  138 "main.c" 1
 1116 002c 7894      		sei
 1117               	 ;  0 "" 2
 143:main.c        **** 
 1119               	.LM118:
 1120               	/* #NOAPP */
 1121 002e 1092 0000 		sts sequenceNo+1,__zero_reg__
 1122 0032 1092 0000 		sts sequenceNo,__zero_reg__
 146:main.c        ****   
 1124               	.LM119:
 1125 0036 81E0      		ldi r24,lo8(1)
 1126 0038 8093 0000 		sts packetReady,r24
 148:main.c        **** 
 1128               	.LM120:
 1129 003c 0E94 0000 		call nrk_init
 150:main.c        **** 
 1131               	.LM121:
 1132 0040 81E0      		ldi r24,lo8(1)
 1133 0042 90E0      		ldi r25,0
 1134 0044 9093 0000 		sts mac_address+1,r25
 1135 0048 8093 0000 		sts mac_address,r24
 157:main.c        ****   nrk_led_clr(BLUE_LED);
 1137               	.LM122:
 1138 004c 82E0      		ldi r24,lo8(2)
 1139 004e 90E0      		ldi r25,0
 1140 0050 0E94 0000 		call nrk_led_clr
 158:main.c        ****   nrk_led_clr(GREEN_LED);
 1142               	.LM123:
 1143 0054 83E0      		ldi r24,lo8(3)
 1144 0056 90E0      		ldi r25,0
 1145 0058 0E94 0000 		call nrk_led_clr
 159:main.c        ****   nrk_led_clr(RED_LED);
 1147               	.LM124:
 1148 005c 81E0      		ldi r24,lo8(1)
 1149 005e 90E0      		ldi r25,0
 1150 0060 0E94 0000 		call nrk_led_clr
 160:main.c        ****  
 1152               	.LM125:
 1153 0064 80E0      		ldi r24,0
 1154 0066 90E0      		ldi r25,0
 1155 0068 0E94 0000 		call nrk_led_clr
 162:main.c        ****   nrk_create_taskset();
 1157               	.LM126:
 1158 006c 20E0      		ldi r18,0
 1159 006e 30E0      		ldi r19,0
 1160 0070 A901      		movw r20,r18
 1161 0072 60E0      		ldi r22,0
 1162 0074 70E0      		ldi r23,0
 1163 0076 CB01      		movw r24,r22
 1164 0078 0E94 0000 		call nrk_time_set
 163:main.c        ****   nrk_start();
 1166               	.LM127:
 1167 007c 0E94 0000 		call nrk_create_taskset
 164:main.c        ****   
 1169               	.LM128:
 1170 0080 0E94 0000 		call nrk_start
 167:main.c        **** 
 1172               	.LM129:
 1173 0084 80E0      		ldi r24,0
 1174 0086 90E0      		ldi r25,0
 1175 0088 0895      		ret
 1177               	.Lscope9:
 1179               		.stabd	78,0,0
 1180               		.section	.progmem.data,"a",@progbits
 1183               	__c.3569:
 1184 0000 436F 756C 		.string	"Could not add slot!\r\n"
 1184      6420 6E6F 
 1184      7420 6164 
 1184      6420 736C 
 1184      6F74 210D 
 1187               	__c.3564:
 1188 0016 4E61 6E6F 		.string	"Nano-RK Version "
 1188      2D52 4B20 
 1188      5665 7273 
 1188      696F 6E20 
 1188      00
 1191               	__c.3554:
 1192 0027 4170 7020 		.string	"App tx_buf Sent\r\n"
 1192      7478 5F62 
 1192      7566 2053 
 1192      656E 740D 
 1192      0A00 
 1193               		.comm	tx_task_info,35,1
 1194               		.comm	tx_task_stack,128,1
 1195               		.comm	rx_task_info,35,1
 1196               		.comm	rx_task_stack,128,1
 1197               		.comm	TaskOne,35,1
 1198               		.comm	Stack1,128,1
 1199               	.global	aes_key
 1200               		.data
 1203               	aes_key:
 1204 0000 00        		.byte	0
 1205 0001 11        		.byte	17
 1206 0002 22        		.byte	34
 1207 0003 33        		.byte	51
 1208 0004 44        		.byte	68
 1209 0005 55        		.byte	85
 1210 0006 66        		.byte	102
 1211 0007 77        		.byte	119
 1212 0008 88        		.byte	-120
 1213 0009 99        		.byte	-103
 1214 000a AA        		.byte	-86
 1215 000b BB        		.byte	-69
 1216 000c CC        		.byte	-52
 1217 000d DD        		.byte	-35
 1218 000e EE        		.byte	-18
 1219 000f FF        		.byte	-1
 1220               		.comm	mac_address,2,1
 1221               		.comm	packetReady,1,1
 1222               		.comm	sequenceNo,2,1
 1223               		.comm	tx_len,1,1
 1224               		.comm	rx_buf,112,1
 1225               		.comm	tx_buf,112,1
 1226               		.comm	i2c_buf,16,1
 1227               		.comm	rx_tdma_fd,18,1
 1228               		.comm	tx_tdma_fd,18,1
 1229               		.comm	tdma_rfTxInfo,7,1
 1230               		.comm	tdma_rfRxInfo,12,1
 1231               		.comm	tdma_enable_signal,1,1
 1232               		.comm	tdma_tx_pkt_done_signal,1,1
 1233               		.comm	tdma_rx_pkt_signal,1,1
 1234               		.comm	_nrk_stats_sleep_time,8,1
 1235               		.comm	cur_task_stats,150,1
 1236               		.comm	app_timer0_prescale,1,1
 1237               		.comm	app_timer0_callback,2,1
 1238               		.comm	_nrk_time_trigger,1,1
 1239               		.comm	_nrk_prev_timer_val,1,1
 1240               		.comm	error_num,1,1
 1241               		.comm	error_task,1,1
 1242               		.comm	nrk_kernel_stk_ptr,2,1
 1243               		.comm	nrk_idle_task_stk,128,1
 1244               		.comm	_nrk_signal_list,4,1
 1277               		.text
 1279               	.Letext0:
 1280               		.ident	"GCC: (GNU) 4.9.1"
 1281               	.global __do_copy_data
 1282               	.global __do_clear_bss
DEFINED SYMBOLS
                            *ABS*:0000000000000000 main.c
/var/folders/5w/cgn1dq610yqf6q25zlv0gqm40000gn/T//ccTRyESS.s:2      *ABS*:000000000000003e __SP_H__
/var/folders/5w/cgn1dq610yqf6q25zlv0gqm40000gn/T//ccTRyESS.s:3      *ABS*:000000000000003d __SP_L__
/var/folders/5w/cgn1dq610yqf6q25zlv0gqm40000gn/T//ccTRyESS.s:4      *ABS*:000000000000003f __SREG__
/var/folders/5w/cgn1dq610yqf6q25zlv0gqm40000gn/T//ccTRyESS.s:5      *ABS*:000000000000003b __RAMPZ__
/var/folders/5w/cgn1dq610yqf6q25zlv0gqm40000gn/T//ccTRyESS.s:6      *ABS*:0000000000000000 __tmp_reg__
/var/folders/5w/cgn1dq610yqf6q25zlv0gqm40000gn/T//ccTRyESS.s:7      *ABS*:0000000000000001 __zero_reg__
/var/folders/5w/cgn1dq610yqf6q25zlv0gqm40000gn/T//ccTRyESS.s:347    .text:0000000000000000 tx_task
                            *COM*:0000000000000070 tx_buf
                            *COM*:0000000000000001 tx_len
                            *COM*:0000000000000012 tx_tdma_fd
/var/folders/5w/cgn1dq610yqf6q25zlv0gqm40000gn/T//ccTRyESS.s:1191   .progmem.data:0000000000000027 __c.3554
/var/folders/5w/cgn1dq610yqf6q25zlv0gqm40000gn/T//ccTRyESS.s:445    .text:0000000000000080 TWI_Act_On_Failure_In_Last_Transmission
/var/folders/5w/cgn1dq610yqf6q25zlv0gqm40000gn/T//ccTRyESS.s:495    .text:00000000000000ae init_itg3200
                            *COM*:0000000000000010 i2c_buf
/var/folders/5w/cgn1dq610yqf6q25zlv0gqm40000gn/T//ccTRyESS.s:530    .text:00000000000000c6 init_hmc5843
/var/folders/5w/cgn1dq610yqf6q25zlv0gqm40000gn/T//ccTRyESS.s:564    .text:00000000000000dc init_adxl345
/var/folders/5w/cgn1dq610yqf6q25zlv0gqm40000gn/T//ccTRyESS.s:642    .text:0000000000000124 task_imu
                            *COM*:0000000000000001 packetReady
                            *COM*:0000000000000002 sequenceNo
/var/folders/5w/cgn1dq610yqf6q25zlv0gqm40000gn/T//ccTRyESS.s:867    .text:0000000000000246 rx_task
/var/folders/5w/cgn1dq610yqf6q25zlv0gqm40000gn/T//ccTRyESS.s:1187   .progmem.data:0000000000000016 __c.3564
                            *COM*:0000000000000002 mac_address
/var/folders/5w/cgn1dq610yqf6q25zlv0gqm40000gn/T//ccTRyESS.s:1183   .progmem.data:0000000000000000 __c.3569
                            *COM*:0000000000000070 rx_buf
                            *COM*:0000000000000012 rx_tdma_fd
/var/folders/5w/cgn1dq610yqf6q25zlv0gqm40000gn/T//ccTRyESS.s:981    .text:00000000000002e4 nrk_create_taskset
                            *COM*:0000000000000023 tx_task_info
                            *COM*:0000000000000080 tx_task_stack
/var/folders/5w/cgn1dq610yqf6q25zlv0gqm40000gn/T//ccTRyESS.s:1080   .text.startup:0000000000000000 main
                            *COM*:0000000000000023 rx_task_info
                            *COM*:0000000000000080 rx_task_stack
                            *COM*:0000000000000023 TaskOne
                            *COM*:0000000000000080 Stack1
/var/folders/5w/cgn1dq610yqf6q25zlv0gqm40000gn/T//ccTRyESS.s:1203   .data:0000000000000000 aes_key
                            *COM*:0000000000000007 tdma_rfTxInfo
                            *COM*:000000000000000c tdma_rfRxInfo
                            *COM*:0000000000000001 tdma_enable_signal
                            *COM*:0000000000000001 tdma_tx_pkt_done_signal
                            *COM*:0000000000000001 tdma_rx_pkt_signal
                            *COM*:0000000000000008 _nrk_stats_sleep_time
                            *COM*:0000000000000096 cur_task_stats
                            *COM*:0000000000000001 app_timer0_prescale
                            *COM*:0000000000000002 app_timer0_callback
                            *COM*:0000000000000001 _nrk_time_trigger
                            *COM*:0000000000000001 _nrk_prev_timer_val
                            *COM*:0000000000000001 error_num
                            *COM*:0000000000000001 error_task
                            *COM*:0000000000000002 nrk_kernel_stk_ptr
                            *COM*:0000000000000080 nrk_idle_task_stk
                            *COM*:0000000000000004 _nrk_signal_list

UNDEFINED SYMBOLS
nrk_get_pid
printf
tdma_started
nrk_wait_until_next_period
sprintf
tdma_send
nrk_kprintf
puts
TWI_Start_Transceiver
TWI_Start_Transceiver_With_Data
tdma_init
tdma_tx_slot_add
tdma_recv
nrk_task_set_entry_function
nrk_task_set_stk
nrk_activate_task
tdma_task_config
nrk_setup_ports
nrk_setup_uart
TWI_Master_Initialise
nrk_init
nrk_led_clr
nrk_time_set
nrk_start
__do_copy_data
__do_clear_bss
